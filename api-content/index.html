{"posts":[{"title":"关于我","content":"欢迎来到我的小站呀，很高兴遇见你！🤝 来认识一下我吧😆 <!-- more --> 🏠 关于本站 我的博客园 本博客是我的新博客，以后只要使用本博客 优质的旧博客应该会放上来 👨‍💻 博主是谁 我是一个广东中山的蒟蒻 生日是2008年10月31日 我很喜欢思维题，是DuckOI的创始人 ⛹ 兴趣爱好 我喜欢二次元，喜欢周杰伦和初音未来 喜欢音乐游戏，玩《Malody》《MaiMai》《舞立方》 喜欢 LoveLive ，但碍于实名认证，不玩游戏 所有实名认证的游戏都不玩 📬 联系我呀 欢迎一起交流！也可以找我们咨询合作！ 微信 DengDuckzs（推荐） 洛谷 DengDuck 私信（推荐） 邮箱 moudengya123@qq.com Bilibili 某邓吖 私信 也可以在下面留言 ","link":"https://Deng-Duck.github.io/post/about/"},{"title":"2022年8月12日模拟赛总结","content":"今天抽出一点时间写总结，最近真的超级忙.....下午要补昨天咕咕的补题 大概是我暑假唯一的博客吧.... <!-- more --> 最近实力漂浮不定，感觉自己应该再成熟一点，不要受太多外界因素干扰 个人成绩 分数： 300/300 排名：1（算上时间的排名：2） 比赛评价 简单。 别急，确实简单，我没有任何夸自己的意思，不要 mod 我，想一想，跟昨天比，这场比赛是不是相对简单? 我个人更倾向于这几次都没考好，教练给的一个信心赛/摸底赛 比赛过程 T1感觉在哪里见过，一眼二分，但是没有好好看题，以为可以自己安排顺序。 往背包上想，感觉会寄，所以打了一个假贪心 所以我的判断函数是这样的.... 那还不如不二分呢，感觉自己是个弱智 这个时候czn大佬表示做完了，Orz 然后做T2，一眼前缀和，切了 然后做T3，显然是递归，但我死活不过样例 然后换了一种表达，A了自己造的所有数据 造化弄人啊... T1发现是规定顺序，那就好办了，优先队列即可 然后调试了半天，发现没有清空，加上就没问题了 然后向教练确认AK.... 开始写总结 题目解析 T1 二分舞台数，然后利用优先队列模拟奶牛上下台 每次提取一个舞台上的奶牛的下台时间的最小值，再把下一个奶牛的下台时间加入优先队列 判断函数复杂度O(nlog⁡n)O(n\\log n)O(nlogn)，二分复杂度O(log⁡n)O(\\log n)O(logn),整体复杂度O(nlog⁡2n)O(n\\log^2 n)O(nlog2n) T2 枚举变换的点，变换前手势，变换后手势三样东西，注意可以不变换 然后求出两个区间的胜场数，这个用前缀和统计即可 注意其实不需要搞清楚谁能打败谁，不如这样想： 我枚举的是一个可以打败xx手势的手势，这样用前缀和统计xx手势的数量就行 O(n)O(n)O(n) T3 设dgx,ydg_{x,y}dgx,y​为变换xxx次后字符串的第yyy项，可以递归解决 {dg0,y=sydgx,y=dgx−1,y(x&gt;0,y≤2x−1n)dgx,y=dgx−1,2x−1n(x&gt;0,y=2x−1n+1)dgx,y=dgx−1，y−2x−1n−1(x&gt;0,y&gt;2x−1n+1)\\begin{cases} dg_{0,y}=s_y\\\\ dg_{x,y}=dg_{x-1,y}(x&gt;0,y\\leq 2^{x-1}n)\\\\ dg_{x,y}=dg_{x-1,2^{x-1}n}(x&gt;0,y= 2^{x-1}n+1)\\\\ dg_{x,y}=dg_{x-1，y-2^{x-1}n-1}(x&gt;0,y&gt; 2^{x-1}n+1) \\end{cases} ⎩⎪⎪⎪⎨⎪⎪⎪⎧​dg0,y​=sy​dgx,y​=dgx−1,y​(x&gt;0,y≤2x−1n)dgx,y​=dgx−1,2x−1n​(x&gt;0,y=2x−1n+1)dgx,y​=dgx−1，y−2x−1n−1​(x&gt;0,y&gt;2x−1n+1)​ 第一个式子不解释 第二个式子相当于两者都有的公共前缀部分，所以一样 第三个式子是第xxx次变换多出来的字符串的第一项，一位循环移位，所以相当于原来的最后一位 第四个式子就是第xxx次变换多出来的字符串（除了第一项），和前面的一样，对齐即可 时间复杂度可以做到O(log⁡n)O(\\log n)O(logn)，我很懒，我的做法是O(log⁡2n)O(\\log^2 n)O(log2n)的 在最后 其实我的代码很累赘，大家理解思路，不要照着打 结果第一是YWJ？CZN后来又交了一次 ","link":"https://Deng-Duck.github.io/post/2022-nian-8-yue-12-ri-mo-ni-sai-zong-jie/"},{"title":"浅谈倍增法求解LCA","content":"倍增法求解LCA是LCA算法中效率较高的一种 本文通过几道题带大家了解这个算法 <!-- more --> Luogu P3379 最近公共祖先 原题展现 题目描述 如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。 输入格式 第一行包含三个正整数 N,M,SN,M,SN,M,S，分别表示树的结点个数、询问的个数和树根结点的序号。 接下来 N−1N-1N−1 行每行包含两个正整数 x,yx, yx,y，表示 xxx 结点和 yyy 结点之间有一条直接连接的边（数据保证可以构成树）。 接下来 MMM 行每行包含两个正整数 a,ba, ba,b，表示询问 aaa 结点和 bbb 结点的最近公共祖先。 输出格式 输出包含 MMM 行，每行包含一个正整数，依次为每一个询问的结果。 样例输入 #1 样例输出 #1 提示 对于 30%30\\%30% 的数据，N≤10N\\leq 10N≤10，M≤10M\\leq 10M≤10。 对于 70%70\\%70% 的数据，N≤10000N\\leq 10000N≤10000，M≤10000M\\leq 10000M≤10000。 对于 100%100\\%100% 的数据，N≤500000N\\leq 500000N≤500000，M≤500000M\\leq 500000M≤500000。 样例说明： 该树结构如下： 第一次询问：2,42, 42,4 的最近公共祖先，故为 444。 第二次询问：3,23, 23,2 的最近公共祖先，故为 444。 第三次询问：3,53, 53,5 的最近公共祖先，故为 111。 第四次询问：1,21, 21,2 的最近公共祖先，故为 444。 第五次询问：4,54, 54,5 的最近公共祖先，故为 444。 故输出依次为 4,4,1,4,44, 4, 1, 4, 44,4,1,4,4。 解析 本题是 LCA 的模板 LCA 的做法很多，比如暴力跳，倍增 暴力跳 让深度大的一点不断向上跳，直到两点深度相等 如果两点深度相同但是并不相等，可以两点一起跳 在随机数据下表现优异，因为树会比较平衡，所以近似O(log⁡n)O(\\log n)O(logn) 通常会被卡成单次O(n)O(n)O(n),其实不难构造，可以构造一个深度大的树（比如链） 本人出的一道题思想类似这样，不过这道题保证了平衡 倍增法 考虑一次跳多一点 记fau,kfa_{u,k}fau,k​表示距离uuu的边数为2k2^k2k的祖先节点则fau,k=fafau,k−1,k−1fa_{u,k}=fa_{fa_{u,k-1},k-1}fau,k​=fafau,k−1​,k−1​可以通过dfs求出fafafa 如果求LCA,我们可以很快让两点来到相同的深度 考虑求两点深度差，将差二进制拆分，每次跳一个222的幂，时间复杂度O(log⁡n)O(\\log n)O(logn) 当然，没必要真的二进制拆分，因为我们要知道是222的几次幂，所以用cmath的log2更加方便 这里有一个优化：用O(n)O(n)O(n)的时间复杂度递推求出log2的值 然后，如果两点深度相同不相等，有一个自认为巧妙的方法求解 一个性质：如果两点跳到LCA了，继续向上跳依然相等（易证） 如果两点向上跳不相等，那么一定可以继续跳 于是想到一个办法：尝试枚举iii从313131到000,表示尝试跳2i2^i2i 如果向上跳不相同的话，就向上跳，这样，枚举完，LCA就是fax,0fa_{x,0}fax,0​ 核心代码如下,首先是预处理 然后是求解 于是，我们得到了一个严格的O(log⁡n)O(\\log n)O(logn)算法 Luogu P1967 [NOIP2013 提高组] 货车运输 原题展现 题目描述 A 国有 nnn 座城市，编号从 111 到 nnn，城市之间有 mmm 条双向道路。每一条道路对车辆都有重量限制，简称限重。 现在有 qqq 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。 输入格式 第一行有两个用一个空格隔开的整数 $ n,m$，表示 AAA 国有 $ n$ 座城市和 mmm 条道路。 接下来 mmm 行每行三个整数 x,y,zx, y, zx,y,z，每两个整数之间用一个空格隔开，表示从 $x $ 号城市到 $ y $ 号城市有一条限重为 zzz 的道路。 注意： x≠yx \\neq yx​=y，两座城市之间可能有多条道路 。 接下来一行有一个整数 qqq，表示有 qqq 辆货车需要运货。 接下来 qqq 行，每行两个整数 x,yx,yx,y，之间用一个空格隔开，表示一辆货车需要从 xxx 城市运输货物到 yyy 城市，保证 x≠yx \\neq yx​=y 输出格式 共有 qqq 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。 如果货车不能到达目的地，输出 −1-1−1。 样例输入 #1 样例输出 #1 提示 对于 30%30\\%30% 的数据，1≤n&lt;10001 \\le n &lt; 10001≤n&lt;1000，1≤m&lt;10,0001 \\le m &lt; 10,0001≤m&lt;10,000，1≤q&lt;10001\\le q&lt; 10001≤q&lt;1000； 对于 60%60\\%60% 的数据，1≤n&lt;10001 \\le n &lt; 10001≤n&lt;1000，1≤m&lt;5×1041 \\le m &lt; 5\\times 10^41≤m&lt;5×104，1≤q&lt;10001 \\le q&lt; 10001≤q&lt;1000； 对于 100%100\\%100% 的数据，1≤n&lt;1041 \\le n &lt; 10^41≤n&lt;104，1≤m&lt;5×1041 \\le m &lt; 5\\times 10^41≤m&lt;5×104，$1 \\le q&lt; 3\\times 10^4 $，0≤z≤1050 \\le z \\le 10^50≤z≤105。 解析 因为我们想要经过的最小边最大，那么不妨构造一个最大生成树（建议使用克鲁斯卡尔算 法），这样每条边都能尽可能大 然后问题转换为树上查询，同样利用倍增法求x−&gt;LCA,y−&gt;LCAx-&gt;LCA,y-&gt;LCAx−&gt;LCA,y−&gt;LCA路径中的最小边，也是可以预处理的 不过问题不保证树联通，需要判断是否有解 克鲁斯卡尔的优势就体现出来了，我们已经处理了并查集，如果两点祖先不同就直接判断为无解 核心代码如下（码风十分奇怪） Duck006[DuckOI]Kill the Duck 原题展现 温馨提示 Duck非常不要脸，单推自己的题 后来发现其实有好多一样的题 贪玩的小孩 HDU 2586 How far away? 题目描述 XCR是世界名列前茅的OIer，今天在打模拟赛。 他已经AC了前四道题，准备暴切第五题，看着这个题面，突然发现不太对.... 他一看五道题的名字 XorCount the Number of Dance SchemesRelaxing TimeAn Easy ProblemKill the DuckXCRAK\\mathtt{\\color{red}{X}\\color{black}{or}}\\\\ \\mathtt{\\color{red}{C}\\color{black}{ount\\;the\\;Number\\;of\\;Dance\\;Schemes}}\\\\ \\mathtt{\\color{red}{R}\\color{black}{elaxing\\;Time }}\\\\ \\mathtt{\\color{red}{A}\\color{black}{n\\; Easy\\;Problem}}\\\\ \\mathtt{\\color{red}{K}\\color{black}{ill\\;the\\;Duck}}\\\\ \\mathtt{\\huge{\\color{red}{XCRAK}}} XorCounttheNumberofDanceSchemesRelaxingTimeAnEasyProblemKilltheDuckXCRAK XCR十分生气，想要杀了DengDuck DengDuck跑到了一个有nnn个结点，n−1n-1n−1条边的树上 这个树的每个边都是无向的，都有边权 XCR现在有mmm次询问，第i(1≤i≤m)i(1 \\leq i \\leq m)i(1≤i≤m)次给出两个正整数xix_ixi​和yiy_iyi​,含义如下 DengDuck 在点 xi(1≤xi≤n)x_i(1 \\leq x_i \\leq n)xi​(1≤xi​≤n) 上,XCR在点 yi(1≤yi≤n)y_i(1 \\leq y_i \\leq n)yi​(1≤yi​≤n) 上 对于每次询问，请问XCR离DengDuck的距离是多少？ 输入格式 第一行一个整数nnn 接下来n−1n-1n−1行每行三个正整数分别表示一条边的起点，终点，边权 第n+1n+1n+1行一个正整数mmm 接下来mmm行每行两个正整数xix_ixi​和yiy_iyi​ 输出格式 有mmm行，每行一个正整数，表示DengDuck和XCR的距离 样例输入 #1 样例输出 #1 样例输入 #2 样例输出 #2 样例输入 #3 样例输出 #3 提示 对于一定的数据 n,mn,mn,m的范围 特殊限制 前5%5\\%5%的数据 1～201～201～20 无 前20%20\\%20%的数据 1～30001～30001～3000 无 另外的5%5\\%5%的数据 1～30001～30001～3000 m=1m=1m=1 所有数据 1～1000001～1000001～100000 无 解析 预处理出disidis_idisi​表示点iii到根111的距离，答案是disx+disy−2dislca(x,y)dis_x+dis_y-2dis_{lca(x,y)}disx​+disy​−2dislca(x,y)​ 非常容易证明 代码如下 [BJWC2010] 严格次小生成树 原题展现 题目描述 小 C 最近学了很多最小生成树的算法，Prim 算法、Kruskal 算法、消圈算法等等。正当小 C 洋洋得意之时，小 P 又来泼小 C 冷水了。小 P 说，让小 C 求出一个无向图的次小生成树，而且这个次小生成树还得是严格次小的，也就是说：如果最小生成树选择的边集是 EME_MEM​，严格次小生成树选择的边集是 ESE_SES​，那么需要满足：(value(e)value(e)value(e) 表示边 eee 的权值) ∑e∈EMvalue(e)&lt;∑e∈ESvalue(e)\\sum_{e \\in E_M}value(e)&lt;\\sum_{e \\in E_S}value(e)∑e∈EM​​value(e)&lt;∑e∈ES​​value(e) 这下小 C 蒙了，他找到了你，希望你帮他解决这个问题。 输入格式 第一行包含两个整数 NNN 和 MMM，表示无向图的点数与边数。 接下来 MMM 行，每行 333 个数 x,y,zx,y,zx,y,z 表示，点 xxx 和点 yyy 之间有一条边，边的权值为 zzz。 输出格式 包含一行，仅一个数，表示严格次小生成树的边权和。 样例输入 #1 样例输出 #1 提示 数据中无向图不保证无自环 对于 50%50\\%50% 的数据， N≤2000N\\le 2000N≤2000，M≤3000M\\le 3000M≤3000。 对于 80%80\\%80% 的数据， N≤5×104N\\le 5\\times 10^4N≤5×104，M≤105M\\le 10^5M≤105。 对于 100%100\\%100% 的数据， N≤105N\\le 10^5N≤105，M≤3×105M\\le 3\\times10^5M≤3×105，边权 ∈[0,109]\\in [0,10^9]∈[0,109]，数据保证必定存在严格次小生成树。 解析 首先，次小生成树与最小生成树不同，但仍然只有n−1n-1n−1条边 所以我们考虑加入一条未选的边，再减去一条选择的边 减去的边应该尽量小，毕竟在求次小生成树 注意如果减去边与加入边权值相同的话，就不是严格次小生成树 为此，我们保存一个严格次小边，以防万一 容易证明这样一定是次小生成树 ","link":"https://Deng-Duck.github.io/post/qian-tan-bei-zeng-fa-qiu-jie-lca/"},{"title":"浅谈BSGS和EXBSGS","content":"我的 BSGS 和各位犇犇的差不多，但是不需要求逆元 其实只要稍微修改，就能避免！ <!-- more --> Luogu [ TJOI2007 ] 可爱的质数 原题展现 题目描述 给定一个质数 ppp，以及一个整数 bbb，一个整数 nnn，现在要求你计算一个最小的非负整数 lll，满足 bl≡n(modp)b^l \\equiv n \\pmod pbl≡n(modp)。 输入格式 仅一行，有 333 个整数，依次代表 p,b,np, b, np,b,n。 输出格式 仅一行，如果有 lll 满足该要求，输出最小的 lll，否则输出 no solution。 样例 #1 样例输入 #1 样例输出 #1 数据规模与约定 对于所有的测试点，保证 2≤b,n&lt;p&lt;2312\\le b,n &lt; p&lt;2^{31}2≤b,n&lt;p&lt;231。 Baby Steps Giant Steps 详解 注意到互质，根据欧拉定理，我们易得l&lt;pl&lt; pl&lt;p，枚举的时间复杂度为O(p)O(p)O(p) 其实可以优化到O(p)O(\\sqrt{p})O(p​)，设 m=⌈p⌉,r=b%mm=\\lceil \\sqrt{p}\\rceil,r=b\\%mm=⌈p​⌉,r=b%m 于是我们可以将 原式写成 bkm+r≡n(mod p)bkm≡nb−r(mod p)b^{km+r}\\equiv n(mod\\;p)\\\\ b^{km}\\equiv nb^{-r}(mod\\;p) bkm+r≡n(modp)bkm≡nb−r(modp) 右边好像要求逆元啊，我们不想求逆元，怎么办呢？ 只需将式子改成 bkm−r≡n(mod p)bkm≡nbr(mod p)b^{km-r}\\equiv n(mod\\;p)\\\\ b^{km}\\equiv nb^{r}(mod\\;p) bkm−r≡n(modp)bkm≡nbr(modp) 解决了问题 我们考虑找到一个 kkk 和 一个 rrr 使得上述式子成立，这个并不难 首先枚举 rrr ，显然有 r(1≤r≤m)r(1\\leq r\\leq m)r(1≤r≤m) 注意这里和广大打法不同 因为广大打法是枚举余数，这里枚举的是相反的 然后把右边式子的值哈希存下，枚举左边的 k(1≤k≤m)k(1\\leq k \\leq m)k(1≤k≤m) 对于左边枚举求出的值看看哈希数组是否存在对应的右边的值，如果有，那么就是一个解 搞出一个最小的解好像也不是很难吧..... 时间复杂度 O(m)O(m)O(m) ，也就是 O(p)O(\\sqrt{p})O(p​) 然后注意一下，要打很多特判 上一下码风巨丑的代码 SPOJ3105 MOD 原题展现 题目描述 给定 a,p,ba,p,ba,p,b，求满足 ax≡b(modp)a^x≡b \\pmod pax≡b(modp) 的最小自然数 xxx 。 输入格式 每个测试文件中包含若干组测试数据，保证 ∑p≤5×106\\sum \\sqrt p\\le 5\\times 10^6∑p​≤5×106。 每组数据中，每行包含 333 个正整数 a,p,ba,p,ba,p,b 。 当 a=p=b=0a=p=b=0a=p=b=0 时，表示测试数据读入完全。 输出格式 对于每组数据，输出一行。 如果无解，输出 No Solution，否则输出最小自然数解。 样例 #1 样例输入 #1 样例输出 #1 数据范围 对于 100%100\\%100% 的数据，1≤a,p,b≤1091\\le a,p,b≤10^91≤a,p,b≤109 或 a=p=b=0a=p=b=0a=p=b=0。 扩展 Baby Steps Giant Steps 详解 注意到不互质，那我们就要想办法让它互质 ax≡b(mod p)ax−kp=b设d=gcd(a,p)若d∣b不成立，则无解式子除d得ax−1ad−kpd=bd改记为ax−1a′−kp′=b′即ax−1a′≡b′(mod p′)a^x\\equiv b(mod\\;p)\\\\ a^x-kp=b\\\\ 设 d=gcd(a,p)\\\\ 若 d|b 不成立，则无解\\\\ 式子除 d 得 a^{x-1}\\frac a d- k\\frac p d=\\frac b d\\\\ 改记为a^{x-1}a&#x27;- kp&#x27;=b&#x27;\\\\ 即 a^{x-1}a&#x27;\\equiv b&#x27;(mod\\; p&#x27;) ax≡b(modp)ax−kp=b设d=gcd(a,p)若d∣b不成立，则无解式子除d得ax−1da​−kdp​=db​改记为ax−1a′−kp′=b′即ax−1a′≡b′(modp′) 如此反复，直到互质为止，差不多就是 ax−cnta′≡b′(mod p′)a^{x-cnt}a&#x27;\\equiv b&#x27;(mod\\; p&#x27;) ax−cnta′≡b′(modp′) 注意，操作时如果两边值相等了，答案就是 cntcntcnt 然后就是个普通 BSGS ,变了一点点，左边需要乘上 a′a&#x27;a′，其他都是一模一样的 求出答案之后答案要加上 cntcntcnt ,因为我们求出的是 x−cntx-cntx−cnt 本题时限高达 4s ，就算不写哈希用 map 也能通过 参考如下实现 大部分 BSGS 题都很明显，随便挑了几道 P4884 多少个 1？ 原题展现 题目描述 给定整数 KKK 和质数 mmm，求最小的正整数 NNN，使得 11⋯111\\cdots 111⋯1（NNN 个 111）≡K(modm)\\equiv K \\pmod m≡K(modm)。 说人话：就是 111⋯1111 mod m=K111\\cdots 1111 \\bmod m = K111⋯1111modm=K。 输入格式 第一行两个整数，分别表示 KKK 和 mmm。 输出格式 一个整数，表示符合条件最小的 NNN。 样例 #1 样例输入 #1 样例输出 #1 提示 30%30\\%30% 的数据保证 m≤106m\\leq 10^6m≤106。 60%60\\%60% 的数据保证 m≤5×107m\\leq 5\\times 10^7m≤5×107。 100%100\\%100% 的数据保证 6≤m≤10116\\leq m\\leq 10^{11}6≤m≤1011，0&lt;K&lt;m0&lt; K&lt; m0&lt;K&lt;m，保证 mmm 是质数。 解法 将式子乘九，再加一，得到一个式子 10N+1=9∗k+1(mod m)10^{N+1}=9*k+1(mod\\; m) 10N+1=9∗k+1(modm) 然后 BSGS 即可 [SDOI2013] 随机数生成器 原题展现 题目背景 小 W 喜欢读书，尤其喜欢读《约翰克里斯朵夫》。 题目描述 最近小 W 准备读一本新书，这本书一共有 ppp 页，页码范围为 0∼p−10 \\sim p-10∼p−1。 小 W 很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用 NOI2012 上学习的线性同余法生成一个序列，来决定每天具体读哪一页。 我们用 xix_ixi​ 来表示通过这种方法生成出来的第 iii 个数，也即小 W 第 iii 天会读哪一页。这个方法需要设置 333 个参数 a,b,x1a,b,x_1a,b,x1​，满足 0≤a,b,x1&lt;p0\\leq a,b,x_1\\lt p0≤a,b,x1​&lt;p，且 a,b,x1a,b,x_1a,b,x1​ 都是整数。按照下面的公式生成出来一系列的整数： xi+1≡a×xi+b(modp)x_{i+1} \\equiv a \\times x_i+b \\pmod p xi+1​≡a×xi​+b(modp) 其中 mod \\bmodmod 表示取余操作。 但是这种方法可能导致某两天读的页码一样。 小 W 要读这本书的第 ttt 页，所以他想知道最早在哪一天能读到第 ttt 页，或者指出他永远不会读到第 ttt 页。 输入格式 本题单测试点内有多组测试数据。 第一行是一个整数 TTT，表示测试数据组数。 接下来 TTT 行，每行有五个整数 p,a,b,x1,tp, a, b, x_1, tp,a,b,x1​,t，表示一组数据。 输出格式 对于每组数据，输出一行一个整数表示他最早读到第 ttt 页是哪一天。如果他永远不会读到第 ttt 页，输出−1-1−1。 样例 #1 样例输入 #1 样例输出 #1 提示 对于全部的测试点，保证： 1≤T≤501 \\leq T \\leq 501≤T≤50。 0≤a,b,x1,t&lt;p0 \\leq a, b, x_1, t \\lt p0≤a,b,x1​,t&lt;p，2≤p≤1092 \\leq p \\leq 10^92≤p≤109。 ppp 为质数。 解法 推式子，我还没做，等几天吧... ","link":"https://Deng-Duck.github.io/post/qian-tan-bsgs-he-exbsgs/"},{"title":"推荐三个好用的TamperMonkey洛谷插件","content":"Tampermonkey 是一款免费的浏览器扩展和最为流行的用户脚本管理器 在我们学习的过程中，往往想要更多功能 这时候可以使用 TamperMonkey 插件进行美化 <!-- more --> Part 1: TamperMonkey 插件 Part 1.1 安装 Tampermonkey Chrome 需要用国内一些小型插件下载站，如：This 请注意个人电脑安全 其他浏览器在软件商店下载，以 Firefox 为例 打开软件商店，This 搜索 Tampermonkey ，下载安装 Part 1.2 对比 Tampermonkey 和 Stylus 大家可能也用过 Stylus美化Luogu，那么两者有什么区别吗？ 代码不兼容（ TamperMonkey 是 JS ,Stylus 是 CSS） Tampermonkey 实现插件较多， Stylus实现美化较多 Tampermonkey &gt; Stylus Tampermonkey 插件的兼容性不如 Stylus 最后一个结论是本人在 Windows 和 Linux 上测试得到的 推荐三个插件 好了，这里推荐三个 Luogu 的插件，都是工具性的 Luogu Search AnyWhere 研发者：tiger2005 最近出品的洛谷搜索引擎，比原来的搜索引擎强大很多 插件下载地址——This 点击上方红圈的**“放大镜”**图例，就可以使用了 如果你没有下载，你会看到一个小小的框子，让你输入题号 但是如果下载成功，就会看到 的界面，就可以搜索力！ 可以搜索用户，搜索题目，搜索帖子 效果图 非常方便我们搜索！ Luogu Tasks 研发者：__ OwO __ 下载链接——This 下载之后，可以在题目界面看见做题助手 你需要用一个题单支撑它，在设置-本地题单输入一个题单号 如图已经配置好了 然后就可以使用了！ 你看，不错吧，非常方便！ 但是，如果添加题需要回到题单一个一个加十分麻烦 可以用助手右上方的添加至列表，快速添加 或者在上图的添加按钮添加 快来试试吧！ Extend-Luogu 制作者：optimize_2 一个被官方半承认的插件！ 不过这个主要是娱乐性的， 下载链接——This 你可以新建一个重现赛 错过了一次比赛，想像真的打比赛一样完成吗 你可以新建一个重现赛！ 你需要输入开始时间 注意：原理是新建一个比赛，所以题目不公开就无法新建 自动填充验证码 帖子等自动填充验证码，有可能错误，但多来一次就可以了 非常舒服 鸣谢 Tothetime_tolife 犇犇指出了链接挂掉 ppip 犇犇补充了 TamperMonkey 是 JS 代码 <!-- more --> ","link":"https://Deng-Duck.github.io/post/tui-jian-san-ge-hao-yong-de-tampermonkey-luo-gu-cha-jian/"},{"title":"2022广东省选普及组没的游记","content":"因为是线上，所以没得游记 <!-- more --> Day 0 GDOI真奇怪，下载一堆奇奇怪怪的东西，因此换成了windows,配置了半天vscode 下午的信心赛打成泄气赛了，初一第四 T4用树的直径的思想做的，寄了 T6简单循环题思路错误，又想到分解了 我发现每次想到分解必出事是吧（NOI ONLINE的数学游戏也想成分解了，0分） T8就是经典的模的循环问题，没打完 T7和T9是水分的 Day 1 完全爆炸，每一道AC的 T1没有判 A=B=C=0A=B=C=0A=B=C=0 的情况 T2想错了，其实就是一个简单的前缀异或 T3打了一个 O(n2)O(n^2)O(n2) 的树形DP T4水分的 听完讲解觉得自己是世界上最大的SB 好吧，将一切希望寄托于Day2 经过一次实战，掌握了这个比赛的出题方向 Day 2 成绩出来了！210！还算可以吧..... 100+0+50+60 不是，为什么T2挂了啊，虽然想错了但不至于0分吧..... T3T4比想象中的分高，好耶! 排名174左右 Day2尝试逆风翻盘 T1看两眼就切了，不就是同余吗，然后就写挂了... 哦，原来是 k=0(modn)k=1(modn)k=2(modn)k=0(mod n)\\\\ k=1(mod n)\\\\ k=2(mod n)\\\\ k=0(modn)k=1(modn)k=2(modn) 得 k=0(modn)k−1=0(modn)k−2=0(modn)k=0(mod n)\\\\ k-1=0(mod n)\\\\ k-2=0(mod n)\\\\ k=0(modn)k−1=0(modn)k−2=0(modn) 啊，那没事了，我写成加一减一了，改了就切了 T2照着样例模拟了一遍就想到正解了，返回有点难搞，哦，没用啊，那没事了 T3是什么垃圾烂题，u1s1，真的出的没水平， 差不多半个小时求完常数，糊了一个代码，希望得分 T4糊了一个O(nm∣S∣)O(nm|S|)O(nm∣S∣)的DP 附一下DP代码 比赛结束，中午出去吃饭，高兴坏了 T1的做法的教授是一样的，应该没问题 T2教授和我的结论不一样，他说是n+Leaves Numbern+Leaves\\;Numbern+LeavesNumber, Leaves NumberLeaves\\;NumberLeavesNumber是叶子节点的个数 我说结论不对，应该是贪心，他看我代码，发现其实我们两个是一样的，nice T3我常数调对了，实现不知道怎么样，听前缀和做法好短啊，60行，我接近300行了 T3代码见后面的附录 T4的DP我的是O(nm∣S∣)O(nm|S|)O(nm∣S∣)的啊，正确性没问题吧 HZX大佬说老师讲了，但我摸鱼没听到，呵呵呵 总结 分数 100+0+50+60+100+100+40+0=450100+0+50+60+100+100+40+0=450 100+0+50+60+100+100+40+0=450 太失望了！ 排名 Day1 174Day2 154 Up 20\\texttt{Day1}\\;\\texttt{174}\\\\ \\texttt{Day2}\\;\\texttt{154}\\;\\color{red}{\\texttt{Up 20}} Day1174Day2154Up 20 没记清楚，差不多这样 希望以后加强思维吧，这次有150150150分都是不该丢的 Day1题解 T1 邹忌讽齐王纳谏 打卡题，建议模拟 建议使用map,时间复杂度为O(nlogn)O(nlogn)O(nlogn) 特判注意数据—— 0≤A,B,C0 \\leq A,B,C 0≤A,B,C 需要特判为0的情况 T2 数列游戏 首先求出前缀异或和，sum1,sum2,sum3,.....sumnsum_1,sum_2,sum_3,.....sum_nsum1​,sum2​,sum3​,.....sumn​， 如果一个区间[l,r][l,r][l,r]异或和为0，那么sumr⊕suml−1=0sum_r⊕sum_{l-1}=0sumr​⊕suml−1​=0 移项得sumr=suml−1sum_r=sum_{l-1}sumr​=suml−1​ 特别注意——如果sumx=0sum_x=0sumx​=0，那就已经可以筛掉xxx了 因此问题是在这些前缀异或和求有多少个不为0的不同的数 T3 流水线 堆优化贪心，一开始m=1m=1m=1(在1上) 随mmm的变大，每次往下加入节点，让max(w1,w2,⋅⋅⋅,wm)max(w_1, w_2, · · · , w_m)max(w1​,w2​,⋅⋅⋅,wm​)尽可能小， 求出过程中的最小值就是答案 也可以使用二分，线段树 这个正确性十分显然 T4 小学生计数题 枚举数字和公差的做法可以拿到60分 蒟蒻也不会，求讲解 大概是求出一整条链，在当中取部分的方案数，使用前缀积+区间逆元解决 希望有犇犇在评论区补充 Day2题解 T1点指兵兵 我们设有xxx个物品，那么最后会指到n mod xn\\;mod\\;xnmodx 根据题意，我们不能让n≡0,1,2(mod x)n\\equiv0,1,2(mod\\;x)n≡0,1,2(modx) 根据同余的可减性，我们得到 n≡0(mod x)n−1≡0(mod x)n−2≡0(mod x)n\\equiv0(mod\\; x)\\\\ n-1\\equiv0(mod\\; x)\\\\ n-2\\equiv0(mod\\; x)\\\\ n≡0(modx)n−1≡0(modx)n−2≡0(modx) 现在很明显了，如果不想让n≡0,1,2(mod x)n\\equiv0,1,2(mod\\;x)n≡0,1,2(modx)，那这个xxx不是n,n−1,n−2n,n-1,n-2n,n−1,n−2的因子 我们可以用O(n)O(\\sqrt{n})O(n​)的复杂度求出三者的因子数量 根据同余性质，是不可能出现重复的，不需要容斥，直接区间-部分即可 ans=n−3+1−n的因子数量−(n−1)的因子数量−(n−2)的因子数量ans=n-3+1-n的因子数量-(n-1)的因子数量-(n-2)的因子数量 ans=n−3+1−n的因子数量−(n−1)的因子数量−(n−2)的因子数量 T2网页浏览 首先不需要返回操作，替换+返回=新建+删除，后者操作性更强 然后，对于一棵树，最优显然是前几个儿子新建，最后一个儿子替换 因为一个网页只有一个父亲，在所有儿子被访问之前，爸爸不能死 但最后一个儿子被访问后，爸爸就可有可无了，这时候使用替换步数更少 对于下面的叶子结点，除了访问，还要删除 我们不难得出一个结论，answer=n+Leaves Numberanswer=n+Leaves\\;Numberanswer=n+LeavesNumber, Leaves NumberLeaves\\;NumberLeavesNumber是叶子节点的个数 因为使用上述方案，每个结点恰好被访问一次，有儿子的节点被最后一个儿子替换，而叶子节点还需要删除自己 所以就是上面的式子了 T3 教室的电子钟 思路非常简单，做法很多，但题目很恶心 最好的做法是六十行的前缀和做法 记录0年1月1日0时0分0秒到xxx年yyy月zzz日aaa时bbb分ccc秒一共消耗了多少单位的电为AAA 记录0年1月1日0时0分0秒到x’x’x’年y’y’y’月z’z’z’日a’a’a’时b’b’b’分c′c&#x27;c′秒一共消耗了多少单位的电为BBB ans=B−A ans=B-A ans=B−A 比本蒟蒻近300行对错未知的做法好多了 T4 机器人 正解是迪杰斯特拉最短路，蒟蒻没听懂 蒟蒻利用一个三维DP得到了大概50分（成绩没出） ","link":"https://Deng-Duck.github.io/post/2022-guang-dong-sheng-xuan-pu-ji-zu-mei-de-you-ji/"},{"title":"JSOI2011分特产题解","content":"这道题很有意思，运用应用了球同盒异可为空模型 而且还套了一层容斥原理，不好想 <!-- more --> 题面描述 JYY 带队参加了若干场ACM/ICPC 比赛，带回了许多土特产，要分给实验室的同学们。 JYY 想知道，把这些特产分给N 个同学，一共有多少种不同的分法？ 当然，JYY 不希望任何一个同学因为没有拿到特产而感到失落，所以每个同学都必须至少分得一个特产。 例如，JYY 带来了2 袋麻花和1 袋包子，分给A 和B 两位同学，那么共有4 种不同的 分配方法： A：麻花，B：麻花、包子 A：麻花、麻花，B：包子 A：包子，B：麻花、麻花 A：麻花、包子，B：麻花 球同盒异可为空模型 这是一个比较经典的模型了，解法非常巧妙，也就是大名鼎鼎的 Cn+m−1m−1C_{n+m-1}^{m-1} Cn+m−1m−1​ 知道的大佬可以跳过了，现在简单讲一下 因为球同，所以使用插板法，但是盒又可以空，两个板总要有什么隔着，所以现在每个盒子放一个球 球同盒异不可为空的插板公式为 Cn−1m−1C_{n-1}^{m-1} Cn−1m−1​ 在箱子放了mmm个球，所以是 Cn+m−1m−1C_{n+m-1}^{m-1} Cn+m−1m−1​ 本题思路 因为本题球有同有异,所以没有公式可以套，但如果将强制xxx人无法选择变成至少xxx人，就相对简单了 那好,至少xxx人,如何求解？ 首先，将这xxx人的组合可能求出来： CnxC_n^x Cnx​ 对于每种特产的分配，都是球同盒异可为空模型，所以是 Πi=1mCai+n−x−1n−x−1\\Pi_{i=1}^{m}C_{a_i+n-x-1}^{n-x-1} Πi=1m​Cai​+n−x−1n−x−1​ 所以对于至少xxx人无法选择 ans=Πi=1mCai+n−x−1n−x−1ans=\\Pi_{i=1}^{m}C_{a_i+n-x-1}^{n-x-1} ans=Πi=1m​Cai​+n−x−1n−x−1​ 设至少xxx人无法选择的方案数为fxf_xfx​,如何求强制xxx人无法选择？ 根据容斥原理，得 ans=f0−f1+f2.....ans=f_0-f_1+f_2..... ans=f0​−f1​+f2​..... ans=∑i=0n(−1)nfians=\\sum_{i=0}^{n}{(-1)}^nf_i ans=i=0∑n​(−1)nfi​ End P.S.：数据很水，组合数请使用杨辉三角 ","link":"https://Deng-Duck.github.io/post/jsoi2011-fen-te-chan-ti-jie/"},{"title":"随便做做NOI ONLINE","content":"NOI ONLINE之前临时抱佛脚 <!-- more --> 好耶！洛谷账号橙了！ 水题 [NOI Online #2 入门组] 未了 这就是一道贪心+二分查找,思路很好想 除法有精度问题，建议不使用除法 code [NOI Online #3 提高组] 水壶 不难发现最优解一定是一个m+1m+1m+1大的区间，问题变成静态区间和 轻轻松松O(n)O(n)O(n)解决 code [NOI Online #3 入门组] 最急救助 字符串水题，直接一个一个字符看（顺便看后两个） 模拟的时间复杂度只有O(n)O(n)O(n) 其实可以加强成KMP的题 code [NOI Online #1 入门组] 文具订购 首次提交只有85，这个水题竟然有坑，奇耻大辱！ 首先应该枚举什么？套数，3元，和4元，为什么？枚举套数快，然后为了买的更多，先枚举3元的 然后倒着枚举，这样第一次求出的就是最优解 code [NOI Online #3 入门组] 观星 先整理星座，然后用一个桶（建议加一个set）存储，最后整理星系，输出 就是一道dfs+模拟，其实本质是一道普及题加上一个普及题（两个部分），但是细节很恶心,容易打错 （xuxiaobin也这么认为） code 较难题 [NOI Online 2021 入门组] 切蛋糕 NOI Online 2021 入门组我其实参加了，但是那时我还是个蒟蒻（现在也是） 当时是拿了100分，也就是只Accepted了本题 本题是一道分类讨论，有一定思维难度，一个一个情况找就对了 code [NOI Online #3 入门组] 买表 读完题很容易发现是多重背包 考虑到 kik_iki​ 很大，要用二进制优化 就当复习了 code [NOI Online #2 提高组] 涂色游戏 一道数学题，一开始没管互质只有40分，后来重推+卡常才Accepted code 变态题 [NOI Online #1 入门组] 魔法 这是入门组的题？！！ 一开始打了一个变形SPFA，但是无法保存魔法，只能使用一次，只拿到50分 正解是矩阵快速幂优化动态规划，我直接放弃，不做了 50pts code ","link":"https://Deng-Duck.github.io/post/sui-bian-zuo-zuo-noi-online/"},{"title":"2022年3月3日模拟赛总结","content":"初一第一 一般，最后一题没打好 不难发现，教练出水了，可能是信心赛 <!-- more --> A.不幸的7 暴力，没有逻辑可言 一些没用的感想 不难发现可以优化，完全不需要存下八进制 本题考察进制转换，不AC就该反思 B.选举 简单的贪心，思路很水，五分钟想出来 先固定A，问题变成让B追上A A和B的初始的距离是什么？ sumA=∑i=1naisumA=\\sum_{i=1}^{n}a_i sumA=i=1∑n​ai​ 如果B什么都不做，A可以获得所有A支持者的选票 那一个城市能缩小多少距离呢 wi=bi+2aiw_i=b_i+2a_i wi​=bi​+2ai​ 首先，去一个城市，B的支持者和A的支持者都支持B，就是bi+aib_i+a_ibi​+ai​, A少了aia_iai​个支持者，也加上去，就这样 关于真实的题目 其实没什么 真的 开long long!,scanf! C. 差的绝对值之和 这道题水炸了，好好想，很有意思，不要直接看题解！ 题解 先排序，按绝对值的性质，从大边累加边算，看看代码吧 有一个易错点，ans += sum - a[i] * (n - i);不要打成ans += sum - a[i] ;， 这个数要和前面所有数计算 D. 路径通过 整体操作，先明确父子关系，然后对于每个操作，理解为对整个树和子树的操作， 最后的dfs统计即可 另一种做法 E. 龙椅 这就是个Exgcd，我打出来真是万幸，就是找正整数解那段忘了，自己的又臭又长 s+1+xk≡1(mod n) s+1+xk \\equiv 1(mod\\ n) s+1+xk≡1(mod n) x为题目所求 化简得 xk−yn=−sxk-yn=-s xk−yn=−s 求即可 第六题待做 ","link":"https://Deng-Duck.github.io/post/20220303/"},{"title":"2021CSP-J网络连接题解","content":"其实这道题不难，作者出成了小模拟 输入也可以利用sscanf解决 <!-- more --> 题目链接 题目分析 map不会冲突！！不一定要like代码中那样加-号！ 模拟，算不上大, 首先，我们想想整个流程: 现在，我们找出难点，逐个瓦解: 读入提取数 MIDDLE 非法情况判断 HARD 是否重复 EASY 从简到难解决。 是否重复 首先，将5个数字按次序组合成一个大数， 本人测试：25525525525565535是long long存的下的， 然后map搞定。 就解决了，参考代码： 读入提取数 怎么提取数字呢? 其实也不难, scanf支持格式输入, 如 scanf(&quot;%d.%d.%d.%d:%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e) 输入 a=1,b=1,c=1,d=1,e=1a=1,b=1,c=1,d=1,e=1a=1,b=1,c=1,d=1,e=1 如果不按格式？ a=1,b=0,c=0,d=0,e=0a=1,b=0,c=0,d=0,e=0a=1,b=0,c=0,d=0,e=0 What?不按格式的部分值没有变化？ 问题三有头绪了呢.... 非法情况判断 通过如上方案，我们将五个数初始化为-1, 如果格式输入后有-1，那格式有误，非法。 参考代码： 同样的，判断数字是否超出范围： 你可能会问，如果输入了一个巨大的数， long long溢出，怎么办？ 别急，我们往下看。 前导零问题如何解决？？ 我们想想，因为前导零被变量“吃”了， 现在的字符串一定比之前的字符串短， 我们判断即可。 怎么存下之前的字符串？ 使用sscanf sscanf不同于scanf,它需要多一个字符串参数 相当于用scanf将字符串内容读了一遍， 读入效果与scanf一样 这样，我们先读入一个字符串， 然后sscanf读入， 这样两个结果都存了下来， 鱼和熊掌的兼得。 其实，非法情况就都可以判走了， 因为 前导零、整数超出、格式错误被判掉。 多个数字显然长度不等。 long long 溢出，长度变小了。 好了，这道题其实不难，重点在函数使用的基本功。 参考代码 ","link":"https://Deng-Duck.github.io/post/2021csp-j-wang-luo-lian-jie-ti-jie/"},{"title":"2021年9月20日模拟赛总结","content":"这次考的是思维题,只做出了雨水 思维不够敏捷，要练 <!-- more --> 第一题：0 第二题：31（最高分56） 第三题：100 第四题：5 总分：136 排名：19 赛后AK 凑数2526 题义： 一个长度为n+m+kn+m+kn+m+k，包含nnn个数字222，mmm个数字555和kkk个数字666的序列，最多可能有多少个子序列是252625262526？ 如果一个序列是数组的子序列，当且仅当这个序列可以由数组删去任意个元素，再将数组中的剩余元素按顺序排列而成。 推导： 思维题，若想最大，要均分nnn，n/2n/2n/2和a−n/2a-n/2a−n/2 比赛时想成排列组合了，Zero 代码： 以后要好好分析，不要想复杂 最小乘积 题义： 在区间[L,R][L,R][L,R]中找两个不同的数，使得它们的乘积模2019最小 推导： 同样是水题 如果r−l&gt;2019r-l &gt;2019r−l&gt;2019,中间必然有201920192019的倍数，输出0 然后直接枚举2019∗20192019*20192019∗2019不会爆， 比赛时的错误太羞耻了，过过过 代码： 雨水 题义： 有nnn座山成环，nnn是奇数,两座山之间有一个水坝。 第iii座山和第i+1i+1i+1座山之间的水坝称为第i个水坝。 第n+1n+1n+1座山也是第111座山，第n+1n+1n+1个水坝也是第111个水坝。 如果第i座山降雨量为fif_ifi​，则它的降雨量会平均地分到相邻两座水坝去。 假设水坝的水全是由山上的降雨提供。 现在给出每一座水坝收到的水量，问每座山的降雨量。 推导： aaa已知，fff未知 根据题义得 ai=(fi+fi+1)/2a_i=(f_i+f_{i+1})/2 ai​=(fi​+fi+1​)/2 交换得 2∗ai=(fi+fi+1)2*a_i=(f_i+f_{i+1}) 2∗ai​=(fi​+fi+1​) 则 fi=2∗ai−fi+1f_i=2*a_i-f_{i+1} fi​=2∗ai​−fi+1​ 然后是重头戏 因为公式中有个未知数代码，要求nnn个公式，肯定不能For 能不能没有未知数？ 以n=3n=3n=3为例，我们尝试消除未知数 求 f1f_1f1​ 时，将 f2f_2f2​ 的算式带入，求 f2f_2f2​ 时,将f3f_3f3​的算式带入 得 f1=2∗a1−2∗a2+2∗a3−f1f_1=2*a_1-2*a_2+2*a_3-f_1 f1​=2∗a1​−2∗a2​+2∗a3​−f1​ 得 2f1=2∗a1−2∗a2+2∗a32f_1=2*a_1-2*a_2+2*a_3 2f1​=2∗a1​−2∗a2​+2∗a3​ 得 f1=a1−a2+a3f_1=a_1-a_2+a_3 f1​=a1​−a2​+a3​ Great! 推出其他未知数 有了f1f_1f1​ 我们可以推出其他未知数 先推出 fnf_nfn​,再倒退其他 代码： 先求f1f_1f1​ 根据上面的公式,奇数加，偶数减 求fnf_nfn​,倒退 完整代码 染色： 题义： 有一棵树，包含n个点，现在你要对所有的点染色，你一共有K种颜色。 两个距离小于等于2的不同顶点，它们必须染成不一样的颜色。 问有多少种染色的方案 推导： DFS即可，实现难，但是思路还是很水的，直接模拟 代码： 请认真看批注！！ ","link":"https://Deng-Duck.github.io/post/20210920/"},{"title":"合并石子三讲","content":"本文讲介绍关于合并石子的做法： 区间DP，记忆化搜索和四边形不等式优化 <!-- more --> 题目大意： 设有 NNN 堆石子排成一排，其编号为 1，2，3，…，N1，2，3，…，N1，2，3，…，N 每堆石子有一定的质量，可以用一个整数来描述 现在要将这 NNN 堆石子合并成为一堆，每次只能合并相邻的两堆 合并的代价为这两堆石子的质量之和 合并后与这两堆石子相邻的石子将和新堆相邻 合并时由于选择的顺序不同，合并的总代价也不相同 找出一种合理的方法，使总的代价最小，输出最小代价 同时输出合并过程 合并石子其实和 合并果子 很像 只是合并 只能相邻，但其实也方便了 区间dp 从最后一次合并开始思考 最后一次合并前，石子肯定只有两堆 ， 设k为两者 中点 ， 也就是两堆中间的位置 第一堆是原来的111到kkk堆，第二堆是原来的第k+1k+1k+1到第nnn堆。 显然， 要使得总代价最小，必然是该两堆式子之前的合并代价最小。 然后不断拆分成子问题解决 定义状态f(i,j)f(i,j)f(i,j) 表示 第i堆石子到第j堆石子 的 最小合并代价 。 目标状态即为f(1,n)f(1,n)f(1,n)。 方程——f(i,j)=min(f(i,k)+f（k+1,j)+sum(i,j)f(i,j)=min(f(i,k)+f（k+1,j)+sum(i,j)f(i,j)=min(f(i,k)+f（k+1,j)+sum(i,j) sum是什么呢？是一个 区间和 ，我们利用 前缀和 可以将询问sum的复杂度降至 O(1) 为什么是 区间和 呢？ 其实 区间和就是两堆的重量（简单，自行思考） 也就是 合并代价 然后是 初始化 因为是求最小值，所以要开一个大数 27其实计算机会认为是一个很大的数，接近int边界，并不是我们认为的27 也可以换成其他数 输入可以同时处理 见代码，sum可以求，因为自己合并自己不需要代价 ，所以f(i,i)f(i,i)f(i,i)始终为0 接下来讲解dp部分 由于我们已经知道起点和区间大小，所以可以求终点 然后枚举中点就完了 这个p是什么呢？ p数组用来记录最优解的中点 Why？ 由于题目要求过程，我们可以用递归求解 这时p就派上用场了 p(i,j)p(i,j)p(i,j)表示合并i,j时的中点k 由此将l,r分成两份，不断递归 好了，这就是关于合并石子的全部内容了 上代码！ 记忆化搜索更加清晰，易于理解 (不过无法使用四边形不等式优化) 浅谈记忆化： 如果说动态规划是递推，那记忆化就是递归 它的思路是： 同动态规划，若子问题的解永远不变，再次计算便没有意义 我们将其记录在 f 数组或dp数组（命名习惯不同） 但动态规划算出了所有子问题 所以，我们用递归求解，保证只求到有用子问题 但其实因为递归实现，二者复杂度接近，动态规划较快 它的框架是： 注意！使用递归函数表示子问题！ 代码详解： 输入，初始化 注意！f = -1 表示 未计算！ 前缀和略 主函数完 求过程略 记忆化部分和动态规划很像，因为我们知道了起点i和终点j 所以处理完边界后，可以直接枚举中点 上代码： 题目大意： 在一圆形操场四周摆放N堆石子 , 现要将石子有次序地合并成一堆. 规定每次只能选相临的两堆合并成一堆,并将新的一堆的石子数,记为该次合并的得分。 编一程序,选择一种合并石子的方案,使得做N-1次合并,得分的总和最少 但数据高达n&lt;=2500 知识讲解： 在动态规划问题中，有一个常见的状态转移方程： f(i,j)=min(f(i,k)+f(k+1,j))+w[i,j]f(i,j)=min(f(i,k)+f(k+1,j))+w[i,j]f(i,j)=min(f(i,k)+f(k+1,j))+w[i,j] 注意上面的粗体部分 min——求最小值 k——枚举的中点 w[i,j]w[i,j]w[i,j]——一个区间处理的函数（如前缀和） 这种公式就是将一个问 题 通过 一个枚举的中点将问题拆成两半，然后加上一个其他利益的计算函数 这种公式若有这三个元素，可以如下判断： w[i,j]w[i,j]w[i,j]是否满足两个性质： 1.若i&lt;i’&lt;j&lt;j’i&lt;i’&lt;j&lt;j’i&lt;i’&lt;j&lt;j’,则w[i′,j]&lt;=w[i,j′]w[i&#x27;,j]&lt;=w[i,j&#x27;]w[i′,j]&lt;=w[i,j′]——区间包含 解析 ：其实很好理解，整个区间是w[i,j′],w[i′,j]w[i,j&#x27;],w[i&#x27;,j]w[i,j′],w[i′,j]是里面的小区间，我们判断时只要看整体里的小区间是否一定小于整体区间即可 如：区间和就是一个区间包含，比如sum（1,6)sum（1,6)sum（1,6)一定大于sum(2,4)sum(2,4)sum(2,4) 2.若i&lt;i’&lt;j&lt;j’i&lt;i’&lt;j&lt;j’i&lt;i’&lt;j&lt;j’,则w(i,j)+w(i′,j′)&lt;=w(i,j′)+w（i′,j)w(i,j)+w(i&#x27;,j&#x27;)&lt;=w(i,j&#x27;)+w（i&#x27;,j)w(i,j)+w(i′,j′)&lt;=w(i,j′)+w（i′,j)——平行四边形不等式。 为什么叫平行四边形不等式？我不知道 但是我们大概记一下即可 可以证明：若w满足区间包含单调性和平行四边形不等式，则f也满足区间平行四边形不等式的性质。 不用记证明，我们记结论 设s(i,j)表示f(i,j)的最佳决策点 也就是f (i,j)为最小值时的中点k 则s满足 {​s(i−1)(j)&lt;=s(i,j)&lt;=s(i)(j+1)​s(i)(j−1)&lt;=s(i,j)&lt;=s(i+1)(j)\\begin{cases} ​ s(i-1)(j)&lt;=s(i,j)&lt;=s(i)(j+1)\\\\ ​ s(i)(j-1)&lt;=s(i,j)&lt;=s(i+1)(j) \\end{cases} {​s(i−1)(j)&lt;=s(i,j)&lt;=s(i)(j+1)​s(i)(j−1)&lt;=s(i,j)&lt;=s(i+1)(j)​ 但只适用于求min 想一想，为什么？ 答案将在树的构造的题解公布 这样，我们可以减少枚举的次数 显然，k的最优解=s(i,j)s(i,j)s(i,j) 范围缩小了 因为我们求s(i,j)s(i,j)s(i,j), 一定需要s(i−1)(j)，s(i)(j+1)s(i-1)(j)，s(i)(j+1)s(i−1)(j)，s(i)(j+1) 或者s(i)(j−1)，s(i+1)(j)s(i)(j-1)，s(i+1)(j)s(i)(j−1)，s(i+1)(j) 所以我们需要选择， 两个不等式，需一个i从大到小枚举，需一个j从大到小枚举 Ps：我们要判断s是否为零，如果为零就仍用i~j 蒟蒻讲的可能不标准，详见PPT 题目详解： 合并石子公式：f(i,j)=min(f(i,l)+f(l+1,j)+w(i,j))f(i,j)=min(f(i,l)+f(l+1,j)+w(i,j))f(i,j)=min(f(i,l)+f(l+1,j)+w(i,j)) 具有三要素 w(i,j)w(i,j)w(i,j)为区间和 满足 区间包含单调性和平行四边形不等式 可以用平行四边形不等式优化 j是由i计算的，所以使用i从大到小的 s(i)(j−1)&lt;=s(i,j)&lt;=s(i+1)(j)s(i)(j-1)&lt;=s(i,j)&lt;=s(i+1)(j)s(i)(j−1)&lt;=s(i,j)&lt;=s(i+1)(j) 代码详解： 大多数和版本二相同 输入和初始化： 对了，这是个环，但做了版本二后环已经废了，就是来加大数据的 求前缀和（略） DP部分 没什么注意的 重点是i从大到小 因为有多种可行方案，所以我们循环要找一个min 输出即可 上代码： 没忍住打了个快读 ","link":"https://Deng-Duck.github.io/post/he-bing-shi-zi-san-jiang/"}]}