

{"themeConfig":{"themeName":"song","postPageSize":25,"archivesPageSize":50,"siteName":"DengDuckのBlog","siteDescription":"<!DOCTYPE HTML>\n<html>\n<body>\n<!-- class =“hitokoto ” 是一言的默认选择器-->\n      <h2 class=\"hitokoto\" id=\"yiyancon\"></h2> \n      \n\t  <script type=\"text/javascript\" src=\"https://international.v1.hitokoto.cn?encode=js&amp;charset=utf-8&amp;c=k\"></script>\n\t\n</body>\n</html>\n\n","footerInfo":"非常好博客，爱来自鸭子！<br/>\n希望大家喜欢我的博客和DuckOI\n","showFeatureImage":true,"domain":"https://Deng-Duck.github.io","postUrlFormat":"SLUG","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD","feedFullText":true,"feedCount":10,"archivesPath":"archives","postPath":"post","tagPath":"tag"},"posts":[{"content":"欢迎来到我的小站呀，很高兴遇见你！🤝 来认识一下我吧😆 🏠 关于本站 我的博客园 本博客是我的新博客，以后只要使用本博客 优质的旧博客应该会放上来 👨‍💻 博主是谁 我是一个广东中山的蒟蒻 生日是2008年10月31日 我很喜欢思维题，是DuckOI的创始人 ⛹ 兴趣爱好 我喜欢二次元，喜欢周杰伦和初音未来 喜欢音乐游戏，玩《Malody》《MaiMai》《舞立方》 喜欢 LoveLive ，但碍于实名认证，不玩游戏 所有实名认证的游戏都不玩 📬 联系我呀 欢迎一起交流！也可以找我们咨询合作！ 微信 DengDuckzs（推荐） 洛谷 DengDuck 私信（推荐） 邮箱 moudengya123@qq.com Bilibili 某邓吖 私信 也可以在下面留言 ","tags":[{"name":"Gridea","slug":"rNPEneU98","used":true,"link":"https://Deng-Duck.github.io/tag/rNPEneU98/"}],"title":"关于我","feature":"https://pica.zhimg.com/v2-7554d41438c66c34bb5cd9cf0c68bcec_1440w.jpg?source=172ae18b","link":"https://Deng-Duck.github.io/post/about/","stats":{"text":"1 min read","time":42000,"words":205,"minutes":1},"date":"2022-08-18 19:09:48","dateFormat":"2022-08-18"},{"content":"今天抽出一点时间写总结，最近真的超级忙.....下午要补昨天咕咕的补题 大概是我暑假唯一的博客吧.... 最近实力漂浮不定，感觉自己应该再成熟一点，不要受太多外界因素干扰 个人成绩 分数： 300/300 排名：1（算上时间的排名：2） 比赛评价 简单。 别急，确实简单，我没有任何夸自己的意思，不要 mod 我，想一想，跟昨天比，这场比赛是不是相对简单? 我个人更倾向于这几次都没考好，教练给的一个信心赛/摸底赛 比赛过程 T1感觉在哪里见过，一眼二分，但是没有好好看题，以为可以自己安排顺序。 往背包上想，感觉会寄，所以打了一个假贪心 所以我的判断函数是这样的.... bool pd(long long x) { memset(b,0,sizeof(b)); int k=1; for(int i=1;i&lt;=n;i++) { if(b[k]+a[i]&gt;t) { k++; } if(k==x+1)return 0; b[k]+=a[i]; } return 1; } 那还不如不二分呢，感觉自己是个弱智 这个时候czn大佬表示做完了，Orz 然后做T2，一眼前缀和，切了 然后做T3，显然是递归，但我死活不过样例 然后换了一种表达，A了自己造的所有数据 造化弄人啊... T1发现是规定顺序，那就好办了，优先队列即可 然后调试了半天，发现没有清空，加上就没问题了 然后向教练确认AK.... 开始写总结 题目解析 T1 二分舞台数，然后利用优先队列模拟奶牛上下台 每次提取一个舞台上的奶牛的下台时间的最小值，再把下一个奶牛的下台时间加入优先队列 判断函数复杂度O(nlog⁡n)O(n\\log n)O(nlogn)，二分复杂度O(log⁡n)O(\\log n)O(logn),整体复杂度O(nlog⁡2n)O(n\\log^2 n)O(nlog2n) #include &lt;bits/stdc++.h&gt; using namespace std; unsigned long long n,t,a[10000005],l,r,ans; priority_queue&lt;unsigned long long,vector&lt;unsigned long long&gt;,greater&lt;unsigned long long&gt; &gt;wt;//迪茵大舞台，有牛你就来 bool pd(unsigned long long x) { while(!wt.empty())wt.pop(); unsigned long long tm=0; for(unsigned long long i=1;i&lt;=x;i++) { wt.push(a[i]); tm=max(tm,a[i]); } for(unsigned long long i=x+1;i&lt;=n;i++) { unsigned long long mn=wt.top(); wt.pop(); wt.push(a[i]+mn); tm=max(tm,a[i]+mn); if(tm&gt;t)return 0; } if(tm&gt;t) { return 0; } return 1; } int main() { cin&gt;&gt;n&gt;&gt;t; for(unsigned long long i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; } l=1;r=n; while(l&lt;=r) { unsigned long long mid=(l+r)&gt;&gt;1; if(pd(mid)) { r=mid-1; ans=mid; } else { l=mid+1; } } cout&lt;&lt;ans; } T2 枚举变换的点，变换前手势，变换后手势三样东西，注意可以不变换 然后求出两个区间的胜场数，这个用前缀和统计即可 注意其实不需要搞清楚谁能打败谁，不如这样想： 我枚举的是一个可以打败xx手势的手势，这样用前缀和统计xx手势的数量就行 O(n)O(n)O(n) #include&lt;bits/stdc++.h&gt; using namespace std; char c; long long n,p[1000005],h[1000005],s[1000005],ans; int main() { cin&gt;&gt;n; for(long long i=1;i&lt;=n;i++) { cin&gt;&gt;c; p[i]=p[i-1]; h[i]=h[i-1]; s[i]=s[i-1]; if(c=='P') { p[i]++; } if(c=='H') { h[i]++; } if(c=='S') { s[i]++; }//统计手势 } for(long long i=1;i&lt;=n;i++)//枚举变换点（在i的右边），不变换可以理解为在n的右边 { long long px=max(p[i]+s[n]-s[i],p[i]+h[n]-h[i]);//使用可以打败p的手势，和变换后的两种情况 long long hx=max(h[i]+p[n]-p[i],h[i]+s[n]-s[i]);//使用可以打败h的手势，和变换后的两种情况 long long sx=max(s[i]+p[n]-p[i],s[i]+h[n]-h[i]);//使用可以打败s的手势，和变换后的两种情况 ans=max(ans,max(px,max(hx,sx)));//统计最大值 } cout&lt;&lt;ans&lt;&lt;endl; } T3 设dgx,ydg_{x,y}dgx,y​为变换xxx次后字符串的第yyy项，可以递归解决 {dg0,y=sydgx,y=dgx−1,y(x&gt;0,y≤2x−1n)dgx,y=dgx−1,2x−1n(x&gt;0,y=2x−1n+1)dgx,y=dgx−1，y−2x−1n−1(x&gt;0,y&gt;2x−1n+1)\\begin{cases} dg_{0,y}=s_y\\\\ dg_{x,y}=dg_{x-1,y}(x&gt;0,y\\leq 2^{x-1}n)\\\\ dg_{x,y}=dg_{x-1,2^{x-1}n}(x&gt;0,y= 2^{x-1}n+1)\\\\ dg_{x,y}=dg_{x-1，y-2^{x-1}n-1}(x&gt;0,y&gt; 2^{x-1}n+1) \\end{cases} ⎩⎪⎪⎪⎨⎪⎪⎪⎧​dg0,y​=sy​dgx,y​=dgx−1,y​(x&gt;0,y≤2x−1n)dgx,y​=dgx−1,2x−1n​(x&gt;0,y=2x−1n+1)dgx,y​=dgx−1，y−2x−1n−1​(x&gt;0,y&gt;2x−1n+1)​ 第一个式子不解释 第二个式子相当于两者都有的公共前缀部分，所以一样 第三个式子是第xxx次变换多出来的字符串的第一项，一位循环移位，所以相当于原来的最后一位 第四个式子就是第xxx次变换多出来的字符串（除了第一项），和前面的一样，对齐即可 时间复杂度可以做到O(log⁡n)O(\\log n)O(logn)，我很懒，我的做法是O(log⁡2n)O(\\log^2 n)O(log2n)的 #include &lt;bits/stdc++.h&gt; using namespace std; string s; long long n, k, t = 1, cnt = 0, pw[65]; char dg(long long k, long long x) { if (k == 0) return s[x - 1]; long long len = pw[k] * n; if (x &lt;= len / 2) return dg(k - 1, x); if (x == len / 2 + 1) return dg(k - 1, len / 2); return dg(k - 1, x - len / 2 - 1); } int main() { pw[0] = 1; for (int i = 1; i &lt;= 64; i++) pw[i] = pw[i - 1] * 2; cin &gt;&gt; s &gt;&gt; k; n = s.size(); while (t * n &lt;= k) t *= 2, cnt++; cout &lt;&lt; dg(cnt, k); } 在最后 其实我的代码很累赘，大家理解思路，不要照着打 结果第一是YWJ？CZN后来又交了一次 ","tags":[{"index":-1,"name":"比赛总结","slug":"Contest","used":true,"link":"https://Deng-Duck.github.io/tag/Contest/"}],"title":"2022年8月12日模拟赛总结","feature":"https://w.wallhaven.cc/full/w8/wallhaven-w8vgvq.jpg","link":"https://Deng-Duck.github.io/post/2022-nian-8-yue-12-ri-mo-ni-sai-zong-jie/","stats":{"text":"8 min read","time":422000,"words":1497,"minutes":8},"date":"2022-08-12 20:22:05","dateFormat":"2022-08-12"},{"content":"倍增法求解LCA是LCA算法中效率较高的一种 本文通过几道题带大家了解这个算法 Luogu P3379 最近公共祖先 原题展现 题目描述 如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。 输入格式 第一行包含三个正整数 N,M,SN,M,SN,M,S，分别表示树的结点个数、询问的个数和树根结点的序号。 接下来 N−1N-1N−1 行每行包含两个正整数 x,yx, yx,y，表示 xxx 结点和 yyy 结点之间有一条直接连接的边（数据保证可以构成树）。 接下来 MMM 行每行包含两个正整数 a,ba, ba,b，表示询问 aaa 结点和 bbb 结点的最近公共祖先。 输出格式 输出包含 MMM 行，每行包含一个正整数，依次为每一个询问的结果。 样例输入 #1 5 5 4 3 1 2 4 5 1 1 4 2 4 3 2 3 5 1 2 4 5 样例输出 #1 4 4 1 4 4 提示 对于 30%30\\%30% 的数据，N≤10N\\leq 10N≤10，M≤10M\\leq 10M≤10。 对于 70%70\\%70% 的数据，N≤10000N\\leq 10000N≤10000，M≤10000M\\leq 10000M≤10000。 对于 100%100\\%100% 的数据，N≤500000N\\leq 500000N≤500000，M≤500000M\\leq 500000M≤500000。 样例说明： 该树结构如下： 第一次询问：2,42, 42,4 的最近公共祖先，故为 444。 第二次询问：3,23, 23,2 的最近公共祖先，故为 444。 第三次询问：3,53, 53,5 的最近公共祖先，故为 111。 第四次询问：1,21, 21,2 的最近公共祖先，故为 444。 第五次询问：4,54, 54,5 的最近公共祖先，故为 444。 故输出依次为 4,4,1,4,44, 4, 1, 4, 44,4,1,4,4。 解析 本题是 LCA 的模板 LCA 的做法很多，比如暴力跳，倍增 暴力跳 让深度大的一点不断向上跳，直到两点深度相等 如果两点深度相同但是并不相等，可以两点一起跳 在随机数据下表现优异，因为树会比较平衡，所以近似O(log⁡n)O(\\log n)O(logn) 通常会被卡成单次O(n)O(n)O(n),其实不难构造，可以构造一个深度大的树（比如链） 本人出的一道题思想类似这样，不过这道题保证了平衡 倍增法 考虑一次跳多一点 记fau,kfa_{u,k}fau,k​表示距离uuu的边数为2k2^k2k的祖先节点则fau,k=fafau,k−1,k−1fa_{u,k}=fa_{fa_{u,k-1},k-1}fau,k​=fafau,k−1​,k−1​可以通过dfs求出fafafa 如果求LCA,我们可以很快让两点来到相同的深度 考虑求两点深度差，将差二进制拆分，每次跳一个222的幂，时间复杂度O(log⁡n)O(\\log n)O(logn) 当然，没必要真的二进制拆分，因为我们要知道是222的几次幂，所以用cmath的log2更加方便 这里有一个优化：用O(n)O(n)O(n)的时间复杂度递推求出log2的值 然后，如果两点深度相同不相等，有一个自认为巧妙的方法求解 一个性质：如果两点跳到LCA了，继续向上跳依然相等（易证） 如果两点向上跳不相等，那么一定可以继续跳 于是想到一个办法：尝试枚举iii从313131到000,表示尝试跳2i2^i2i 如果向上跳不相同的话，就向上跳，这样，枚举完，LCA就是fax,0fa_{x,0}fax,0​ 核心代码如下,首先是预处理 void dfs(long long x,long long fa) { f[x][0]=fa; dep[x]=dep[fa]+1; for(int i=1;i&lt;=31;i++) { f[x][i]=f[f[x][i-1]][i-1]; } for(int i=h[x];i;i=a[i].next) { if(a[i].to!=fa) { dfs(a[i].to,x); } } } 然后是求解 if(dep[x]&lt;dep[y]) { swap(x,y); } while(dep[x] &gt; dep[y]) { x = f[x][lg[dep[x]-dep[y]] - 1]; } if(x==y) { cout&lt;&lt;x&lt;&lt;endl; continue; } for(int k = lg[dep[x]] - 1; k &gt;= 0;k--) { if(f[x][k] != f[y][k]) { x = f[x][k], y = f[y][k]; } } 于是，我们得到了一个严格的O(log⁡n)O(\\log n)O(logn)算法 Luogu P1967 [NOIP2013 提高组] 货车运输 原题展现 题目描述 A 国有 nnn 座城市，编号从 111 到 nnn，城市之间有 mmm 条双向道路。每一条道路对车辆都有重量限制，简称限重。 现在有 qqq 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。 输入格式 第一行有两个用一个空格隔开的整数 $ n,m$，表示 AAA 国有 $ n$ 座城市和 mmm 条道路。 接下来 mmm 行每行三个整数 x,y,zx, y, zx,y,z，每两个整数之间用一个空格隔开，表示从 $x $ 号城市到 $ y $ 号城市有一条限重为 zzz 的道路。 注意： x≠yx \\neq yx​=y，两座城市之间可能有多条道路 。 接下来一行有一个整数 qqq，表示有 qqq 辆货车需要运货。 接下来 qqq 行，每行两个整数 x,yx,yx,y，之间用一个空格隔开，表示一辆货车需要从 xxx 城市运输货物到 yyy 城市，保证 x≠yx \\neq yx​=y 输出格式 共有 qqq 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。 如果货车不能到达目的地，输出 −1-1−1。 样例输入 #1 4 3 1 2 4 2 3 3 3 1 1 3 1 3 1 4 1 3 样例输出 #1 3 -1 3 提示 对于 30%30\\%30% 的数据，1≤n&lt;10001 \\le n &lt; 10001≤n&lt;1000，1≤m&lt;10,0001 \\le m &lt; 10,0001≤m&lt;10,000，1≤q&lt;10001\\le q&lt; 10001≤q&lt;1000； 对于 60%60\\%60% 的数据，1≤n&lt;10001 \\le n &lt; 10001≤n&lt;1000，1≤m&lt;5×1041 \\le m &lt; 5\\times 10^41≤m&lt;5×104，1≤q&lt;10001 \\le q&lt; 10001≤q&lt;1000； 对于 100%100\\%100% 的数据，1≤n&lt;1041 \\le n &lt; 10^41≤n&lt;104，1≤m&lt;5×1041 \\le m &lt; 5\\times 10^41≤m&lt;5×104，$1 \\le q&lt; 3\\times 10^4 $，0≤z≤1050 \\le z \\le 10^50≤z≤105。 解析 因为我们想要经过的最小边最大，那么不妨构造一个最大生成树（建议使用克鲁斯卡尔算 法），这样每条边都能尽可能大 然后问题转换为树上查询，同样利用倍增法求x−&gt;LCA,y−&gt;LCAx-&gt;LCA,y-&gt;LCAx−&gt;LCA,y−&gt;LCA路径中的最小边，也是可以预处理的 不过问题不保证树联通，需要判断是否有解 克鲁斯卡尔的优势就体现出来了，我们已经处理了并查集，如果两点祖先不同就直接判断为无解 核心代码如下（码风十分奇怪） #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; struct road { ll s,t,w; }r[200005]; struct node { ll to,next,w; }a[200005]; ll n,m,t,k,x,y,fa2[100005],h[100005],fa[100005][33],f[100005][33],dep[100005],lg[100005]; bool cmp(road x,road y) { return x.w&gt;y.w; } void add(int x,int y,int z) { t++; a[t].to=y; a[t].w=z; a[t].next=h[x]; h[x]=t; } int find(int x) { if(fa2[x]==x)return x; return fa2[x]=find(fa2[x]); } void dfs(long long x,long long fn) { fa[x][0]=fn; dep[x]=dep[fn]+1; for(int i=1;i&lt;=31;i++) { fa[x][i]=fa[fa[x][i-1]][i-1]; f[x][i]=min(f[x][i-1],f[fa[x][i-1]][i-1]);//f数组表示x到fa[x][i]路径的最小值 } for(int i=h[x];i;i=a[i].next) { if(a[i].to!=fn) { f[a[i].to][0]=a[i].w; dfs(a[i].to,x); } } } int lca(int x,int y) { if(dep[x]&lt;dep[y]) { swap(x,y); } while(dep[x] &gt; dep[y]) { x = fa[x][lg[dep[x]-dep[y]] - 1]; } if(x==y) { return x; } for(int k = lg[dep[x]] - 1; k &gt;= 0;k--) { if(fa[x][k] != fa[y][k]) { x = fa[x][k], y = fa[y][k]; } } return fa[x][0]; } int work(int x,int y)//求解x到y路径的最小值，保证y是x祖先 { ll ans=1e9,deph=dep[x]-dep[y]; while(deph!=0) { ll t=lg[deph]-1; ans=min(ans,f[x][t]); x=fa[x][t]; deph=dep[x]-dep[y]; } return ans; } int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) { fa2[i]=i; lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i); } for(int i=1;i&lt;=m;i++) { cin&gt;&gt;r[i].s&gt;&gt;r[i].t&gt;&gt;r[i].w; } sort(r+1,r+m+1,cmp);//克鲁斯卡尔 int k=n-1; for(int i=1;i&lt;=m;i++) { if(k==0)break; if(find(r[i].s)!=find(r[i].t)) { add(r[i].s,r[i].t,r[i].w); add(r[i].t,r[i].s,r[i].w); fa2[find(r[i].s)]=find(r[i].t); k--; } } for(int i=1;i&lt;=n;i++) { if(find(i)==i) { dfs(i,0); } } cin&gt;&gt;k; for(int i=1;i&lt;=k;i++) { cin&gt;&gt;x&gt;&gt;y; if(find(x)!=find(y)) { cout&lt;&lt;-1&lt;&lt;endl; continue; } int lcah=lca(x,y); cout&lt;&lt;min(work(x,lcah),work(y,lcah))&lt;&lt;endl; } } Duck006[DuckOI]Kill the Duck 原题展现 温馨提示 Duck非常不要脸，单推自己的题 后来发现其实有好多一样的题 贪玩的小孩 HDU 2586 How far away? 题目描述 XCR是世界名列前茅的OIer，今天在打模拟赛。 他已经AC了前四道题，准备暴切第五题，看着这个题面，突然发现不太对.... 他一看五道题的名字 XorCount the Number of Dance SchemesRelaxing TimeAn Easy ProblemKill the DuckXCRAK\\mathtt{\\color{red}{X}\\color{black}{or}}\\\\ \\mathtt{\\color{red}{C}\\color{black}{ount\\;the\\;Number\\;of\\;Dance\\;Schemes}}\\\\ \\mathtt{\\color{red}{R}\\color{black}{elaxing\\;Time }}\\\\ \\mathtt{\\color{red}{A}\\color{black}{n\\; Easy\\;Problem}}\\\\ \\mathtt{\\color{red}{K}\\color{black}{ill\\;the\\;Duck}}\\\\ \\mathtt{\\huge{\\color{red}{XCRAK}}} XorCounttheNumberofDanceSchemesRelaxingTimeAnEasyProblemKilltheDuckXCRAK XCR十分生气，想要杀了DengDuck DengDuck跑到了一个有nnn个结点，n−1n-1n−1条边的树上 这个树的每个边都是无向的，都有边权 XCR现在有mmm次询问，第i(1≤i≤m)i(1 \\leq i \\leq m)i(1≤i≤m)次给出两个正整数xix_ixi​和yiy_iyi​,含义如下 DengDuck 在点 xi(1≤xi≤n)x_i(1 \\leq x_i \\leq n)xi​(1≤xi​≤n) 上,XCR在点 yi(1≤yi≤n)y_i(1 \\leq y_i \\leq n)yi​(1≤yi​≤n) 上 对于每次询问，请问XCR离DengDuck的距离是多少？ 输入格式 第一行一个整数nnn 接下来n−1n-1n−1行每行三个正整数分别表示一条边的起点，终点，边权 第n+1n+1n+1行一个正整数mmm 接下来mmm行每行两个正整数xix_ixi​和yiy_iyi​ 输出格式 有mmm行，每行一个正整数，表示DengDuck和XCR的距离 样例输入 #1 3 1 2 3 2 3 4 2 1 2 1 3 样例输出 #1 3 7 样例输入 #2 3 1 3 10 1 2 13 5 1 1 2 2 3 1 2 1 1 3 样例输出 #2 0 0 10 13 10 样例输入 #3 14 5 7 12 7 11 15 5 14 12 14 3 17 7 1 19 14 4 14 1 12 16 1 6 16 12 9 19 9 10 10 7 2 11 4 8 10 2 13 14 17 6 11 14 14 13 11 6 10 12 6 8 7 9 9 10 11 13 10 1 4 2 12 13 4 2 7 2 1 12 2 10 11 4 7 样例输出 #3 50 0 40 61 32 48 0 79 89 57 46 63 11 30 46 79 38 提示 对于一定的数据 n,mn,mn,m的范围 特殊限制 前5%5\\%5%的数据 1～201～201～20 无 前20%20\\%20%的数据 1～30001～30001～3000 无 另外的5%5\\%5%的数据 1～30001～30001～3000 m=1m=1m=1 所有数据 1～1000001～1000001～100000 无 解析 预处理出disidis_idisi​表示点iii到根111的距离，答案是disx+disy−2dislca(x,y)dis_x+dis_y-2dis_{lca(x,y)}disx​+disy​−2dislca(x,y)​ 非常容易证明 代码如下 #include &lt;bits/stdc++.h&gt; using namespace std; int n, k, b[1000005], x, y, z, tot, h[500005], len[500005], fa[500005][33], dep[500005], lg[500005], f[1000005], ans; struct node { int to, next, w; } a[1000005]; void dfs(long long x, long long fn, long long l) { fa[x][0] = fn; dep[x] = dep[fn] + 1; len[x] = l; for (int i = 1; i &lt;= 31; i++) { fa[x][i] = fa[fa[x][i - 1]][i - 1]; } for (int i = h[x]; i; i = a[i].next) { if (a[i].to != fn) { dfs(a[i].to, x, l + a[i].w); } } } int lca(int x, int y) { if (dep[x] &lt; dep[y]) { swap(x, y); } while (dep[x] &gt; dep[y]) { x = fa[x][lg[dep[x] - dep[y]] - 1]; } if (x == y) { return x; } for (int k = lg[dep[x]] - 1; k &gt;= 0; k--) { if (fa[x][k] != fa[y][k]) { x = fa[x][k], y = fa[y][k]; } } return fa[x][0]; } void add(int x, int y, int z) { ++tot; a[tot].to = y; a[tot].next = h[x]; a[tot].w = z; h[x] = tot; } void answer(int x, int fn) { for (int i = h[x]; i; i = a[i].next) { if (a[i].to != fn) { answer(a[i].to, x); f[x] += f[a[i].to]; } } ans = max(ans, f[x]); } int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i); } for (int i = 1; i &lt;= n - 1; i++) { cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; add(x, y, z); add(y, x, z); } dfs(1, 0, 0); cin &gt;&gt; k; for (int i = 1; i &lt;= k; i++) { cin &gt;&gt; x &gt;&gt; y; int t = lca(x, y); cout &lt;&lt; len[x] + len[y] - 2 * len[t] &lt;&lt; endl; } } [BJWC2010] 严格次小生成树 原题展现 题目描述 小 C 最近学了很多最小生成树的算法，Prim 算法、Kruskal 算法、消圈算法等等。正当小 C 洋洋得意之时，小 P 又来泼小 C 冷水了。小 P 说，让小 C 求出一个无向图的次小生成树，而且这个次小生成树还得是严格次小的，也就是说：如果最小生成树选择的边集是 EME_MEM​，严格次小生成树选择的边集是 ESE_SES​，那么需要满足：(value(e)value(e)value(e) 表示边 eee 的权值) ∑e∈EMvalue(e)&lt;∑e∈ESvalue(e)\\sum_{e \\in E_M}value(e)&lt;\\sum_{e \\in E_S}value(e)∑e∈EM​​value(e)&lt;∑e∈ES​​value(e) 这下小 C 蒙了，他找到了你，希望你帮他解决这个问题。 输入格式 第一行包含两个整数 NNN 和 MMM，表示无向图的点数与边数。 接下来 MMM 行，每行 333 个数 x,y,zx,y,zx,y,z 表示，点 xxx 和点 yyy 之间有一条边，边的权值为 zzz。 输出格式 包含一行，仅一个数，表示严格次小生成树的边权和。 样例输入 #1 5 6 1 2 1 1 3 2 2 4 3 3 5 4 3 4 3 4 5 6 样例输出 #1 11 提示 数据中无向图不保证无自环 对于 50%50\\%50% 的数据， N≤2000N\\le 2000N≤2000，M≤3000M\\le 3000M≤3000。 对于 80%80\\%80% 的数据， N≤5×104N\\le 5\\times 10^4N≤5×104，M≤105M\\le 10^5M≤105。 对于 100%100\\%100% 的数据， N≤105N\\le 10^5N≤105，M≤3×105M\\le 3\\times10^5M≤3×105，边权 ∈[0,109]\\in [0,10^9]∈[0,109]，数据保证必定存在严格次小生成树。 解析 首先，次小生成树与最小生成树不同，但仍然只有n−1n-1n−1条边 所以我们考虑加入一条未选的边，再减去一条选择的边 减去的边应该尽量小，毕竟在求次小生成树 注意如果减去边与加入边权值相同的话，就不是严格次小生成树 为此，我们保存一个严格次小边，以防万一 容易证明这样一定是次小生成树 #include &lt;bits/stdc++.h&gt; using namespace std; long long t, tt, fac[1000005], n, m, x, y, cnt, z, sum, ans = 1e18, h[1000005], fir[1000005][33], sec[1000005][33], fa[1000005][33], dep[100005]; bool vis[1000005]; inline long long read() { long long ans = 0; char c = getchar(); while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c != '-')) { c = getchar(); } ans = c - '0'; c = getchar(); while (c &gt;= '0' &amp;&amp; c &lt;= '9') { ans = (ans &lt;&lt; 3) + (ans &lt;&lt; 1) + c - '0'; c = getchar(); } return ans; } struct node { long long s, t, w; } a[1000005]; struct nod { long long to, w, next; } b[1000005]; void add(long long x, long long y, long long z) { t++; a[t].s = x; a[t].t = y; a[t].w = z; } void adde(long long x, long long y, long long z) { tt++; b[tt].to = y; b[tt].w = z; b[tt].next = h[x]; h[x] = tt; } long long find(long long x) { if (fac[x] != x) { fac[x] = find(fac[x]); } return fac[x]; } long long cmp(node x, node y) { return x.w &lt; y.w; } void dfs(long long x, long long y) { fa[x][0] = y; for (long long j = 1; j &lt;= 32; j++) { fa[x][j] = fa[fa[x][j - 1]][j - 1]; fir[x][j] = max(fir[x][j - 1], fir[fa[x][j - 1]][j - 1]); sec[x][j] = max(sec[x][j - 1], sec[fa[x][j - 1]][j - 1]); if (fir[x][j - 1] &gt; fir[fa[x][j - 1]][j - 1]) { sec[x][j] = max(fir[fa[x][j - 1]][j - 1], sec[x][j]); } else if (fir[x][j - 1] &lt; fir[fa[x][j - 1]][j - 1]) { sec[x][j] = max(fir[x][j - 1], sec[x][j]); } } for (long long i = h[x]; i; i = b[i].next) { if (y != b[i].to) { dep[b[i].to] = dep[x] + 1; fir[b[i].to][0] = b[i].w; sec[b[i].to][0] = -1e18; dfs(b[i].to, x); } } } long long lca(long long x, long long y) { if (dep[x] &lt; dep[y]) { swap(x, y); } for (long long i = 32; i &gt;= 0; i--) { if (dep[fa[x][i]] &gt;= dep[y]) { x = fa[x][i]; } } if (x == y) { return x; } for (long long i = 32; i &gt;= 0 &amp;&amp; x != y; i--) { if (fa[x][i] != fa[y][i]) { x = fa[x][i], y = fa[y][i]; } } return fa[x][0]; } long long query(long long s, long long t, long long w) { long long cnt = -1e18; for (long long i = 32; i &gt;= 0; i--) { if (dep[fa[s][i]] &gt;= dep[t]) { if (w != fir[s][i]) cnt = max(cnt, fir[s][i]); else cnt = max(cnt, sec[s][i]); s = fa[t][i]; } } return cnt; } int main() { memset(b, false, sizeof(b)); n = read(), m = read(); for (long long i = 1; i &lt;= m; i++) { x = read(), y = read(), z = read(); add(x, y, z); fac[i] = i; } sort(a + 1, a + m + 1, cmp); for (long long j = 1; j &lt;= m; j++) { long long fa1 = find(a[j].s); long long fa2 = find(a[j].t); if (fa1 != fa2) { sum += a[j].w; adde(a[j].s, a[j].t, a[j].w); adde(a[j].t, a[j].s, a[j].w); vis[j] = 1; fac[fa1] = fa2; cnt++; if (cnt == n - 1) { break; } } } sec[1][0] = -1e18; dep[1] = 1; dfs(1, 0); ans = 1e18; for (long long i = 1; i &lt;= t; i++) { if (!vis[i]) { long long st = a[i].s; long long ed = a[i].t; long long fat = lca(st, ed); long long l = query(st, fat, a[i].w); long long r = query(ed, fat, a[i].w); ans = min(ans, sum - max(l, r) + a[i].w); } } cout &lt;&lt; ans; } ","tags":[{"index":-1,"name":"算法总结","slug":"Algorithm","used":true,"link":"https://Deng-Duck.github.io/tag/Algorithm/"}],"title":"浅谈倍增法求解LCA","feature":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwallpaperm.cmcm.com%2Fc9899ba117b0cff3ce98bd3ed39c3f7e.jpg&refer=http%3A%2F%2Fwallpaperm.cmcm.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1663501361&t=6c7f41faee22d1a323374d1463be1c3c","link":"https://Deng-Duck.github.io/post/qian-tan-bei-zeng-fa-qiu-jie-lca/","stats":{"text":"23 min read","time":1322000,"words":4440,"minutes":23},"date":"2022-06-09 19:44:24","dateFormat":"2022-06-09"},{"content":"我的 BSGS 和各位犇犇的差不多，但是不需要求逆元 其实只要稍微修改，就能避免！ Luogu [ TJOI2007 ] 可爱的质数 原题展现 题目描述 给定一个质数 ppp，以及一个整数 bbb，一个整数 nnn，现在要求你计算一个最小的非负整数 lll，满足 bl≡n(modp)b^l \\equiv n \\pmod pbl≡n(modp)。 输入格式 仅一行，有 333 个整数，依次代表 p,b,np, b, np,b,n。 输出格式 仅一行，如果有 lll 满足该要求，输出最小的 lll，否则输出 no solution。 样例 #1 样例输入 #1 5 2 3 样例输出 #1 3 数据规模与约定 对于所有的测试点，保证 2≤b,n&lt;p&lt;2312\\le b,n &lt; p&lt;2^{31}2≤b,n&lt;p&lt;231。 Baby Steps Giant Steps 详解 注意到互质，根据欧拉定理，我们易得l&lt;pl&lt; pl&lt;p，枚举的时间复杂度为O(p)O(p)O(p) 其实可以优化到O(p)O(\\sqrt{p})O(p​)，设 m=⌈p⌉,r=b%mm=\\lceil \\sqrt{p}\\rceil,r=b\\%mm=⌈p​⌉,r=b%m 于是我们可以将 原式写成 bkm+r≡n(mod p)bkm≡nb−r(mod p)b^{km+r}\\equiv n(mod\\;p)\\\\ b^{km}\\equiv nb^{-r}(mod\\;p) bkm+r≡n(modp)bkm≡nb−r(modp) 右边好像要求逆元啊，我们不想求逆元，怎么办呢？ 只需将式子改成 bkm−r≡n(mod p)bkm≡nbr(mod p)b^{km-r}\\equiv n(mod\\;p)\\\\ b^{km}\\equiv nb^{r}(mod\\;p) bkm−r≡n(modp)bkm≡nbr(modp) 解决了问题 我们考虑找到一个 kkk 和 一个 rrr 使得上述式子成立，这个并不难 首先枚举 rrr ，显然有 r(1≤r≤m)r(1\\leq r\\leq m)r(1≤r≤m) 注意这里和广大打法不同 因为广大打法是枚举余数，这里枚举的是相反的 然后把右边式子的值哈希存下，枚举左边的 k(1≤k≤m)k(1\\leq k \\leq m)k(1≤k≤m) 对于左边枚举求出的值看看哈希数组是否存在对应的右边的值，如果有，那么就是一个解 搞出一个最小的解好像也不是很难吧..... 时间复杂度 O(m)O(m)O(m) ，也就是 O(p)O(\\sqrt{p})O(p​) 然后注意一下，要打很多特判 上一下码风巨丑的代码 inline ll ksc(ll x, ll y, const ll&amp; p) { return (x * y - (ll)((long double)x / p * y) * p + p) % p; } vector&lt;pair&lt;ll, int&gt; &gt; v[ 100013]; inline ll BSGS(ll a, ll b, const ll&amp;p) { if (b == 1) { if (a == 0) return -1; return 1; } if (b == 0) { if (a == 0) return 1; return -1; } if (a == 0) { return -1; } ll m = ceil(sqrt(p)), cnt = 1, res = 1; for (int r = 1; r &lt;= m; r++) { cnt = ksc(cnt, a, p);//这个龟速乘不是龟速乘 v[(ksc(cnt, b, p)) % mod].push_back(make_pair(ksc(cnt, b, p), r)); } for (int k = 1; k &lt;= m; k++) { res = ksc(cnt, res, p); ll id=res%mod; if (v[id].size()) { for (int j = v[id].size() - 1; j &gt;= 0; j--) { if (v[id][j].first ==res) { return m * k - v[id][j].second; } } } } return -1; } SPOJ3105 MOD 原题展现 题目描述 给定 a,p,ba,p,ba,p,b，求满足 ax≡b(modp)a^x≡b \\pmod pax≡b(modp) 的最小自然数 xxx 。 输入格式 每个测试文件中包含若干组测试数据，保证 ∑p≤5×106\\sum \\sqrt p\\le 5\\times 10^6∑p​≤5×106。 每组数据中，每行包含 333 个正整数 a,p,ba,p,ba,p,b 。 当 a=p=b=0a=p=b=0a=p=b=0 时，表示测试数据读入完全。 输出格式 对于每组数据，输出一行。 如果无解，输出 No Solution，否则输出最小自然数解。 样例 #1 样例输入 #1 5 58 33 2 4 3 0 0 0 样例输出 #1 9 No Solution 数据范围 对于 100%100\\%100% 的数据，1≤a,p,b≤1091\\le a,p,b≤10^91≤a,p,b≤109 或 a=p=b=0a=p=b=0a=p=b=0。 扩展 Baby Steps Giant Steps 详解 注意到不互质，那我们就要想办法让它互质 ax≡b(mod p)ax−kp=b设d=gcd(a,p)若d∣b不成立，则无解式子除d得ax−1ad−kpd=bd改记为ax−1a′−kp′=b′即ax−1a′≡b′(mod p′)a^x\\equiv b(mod\\;p)\\\\ a^x-kp=b\\\\ 设 d=gcd(a,p)\\\\ 若 d|b 不成立，则无解\\\\ 式子除 d 得 a^{x-1}\\frac a d- k\\frac p d=\\frac b d\\\\ 改记为a^{x-1}a&#x27;- kp&#x27;=b&#x27;\\\\ 即 a^{x-1}a&#x27;\\equiv b&#x27;(mod\\; p&#x27;) ax≡b(modp)ax−kp=b设d=gcd(a,p)若d∣b不成立，则无解式子除d得ax−1da​−kdp​=db​改记为ax−1a′−kp′=b′即ax−1a′≡b′(modp′) 如此反复，直到互质为止，差不多就是 ax−cnta′≡b′(mod p′)a^{x-cnt}a&#x27;\\equiv b&#x27;(mod\\; p&#x27;) ax−cnta′≡b′(modp′) 注意，操作时如果两边值相等了，答案就是 cntcntcnt 然后就是个普通 BSGS ,变了一点点，左边需要乘上 a′a&#x27;a′，其他都是一模一样的 求出答案之后答案要加上 cntcntcnt ,因为我们求出的是 x−cntx-cntx−cnt 本题时限高达 4s ，就算不写哈希用 map 也能通过 参考如下实现 vector&lt;pair&lt;ll, int&gt; &gt; v[ 1000013]; int vis[1000003]; inline ll exBSGS(ll a,ll b,ll p) { memset( vis,0,sizeof(vis)); if(p==0)return -1; if(p==1) { if(b==0)return 0; return -1; } if (b == 1) { if (a == 0) return -1; return 1; } if (b == 0) { if (a == 0) return 1; return -1; } if (a == 0) { return -1; } ll ak=0,t=1,d=gcd(a,p); while(d!=1) { ak++; t*=a; t/=d; p/=d; if(b%d!=0)return -1; b/=d; if(t%p==b%p)return ak; d=gcd(a,p); t%=p; } ll m = ceil(sqrt(p)), res=t%p,cnt=1; for (int r = 1; r &lt;= m; r++) { cnt = ksc(cnt, a, p); ll hash=(ksc(cnt, b, p)) % mod; if(vis[hash]==0) { vis[hash]=1; v[hash].clear(); } v[hash].push_back(make_pair(ksc(cnt, b, p), r)); } for (int k = 1; k &lt;= m; k++) { res = ksc(cnt, res, p); ll hash=res%mod; if (vis[hash]) { for (int j = v[hash].size() - 1; j &gt;= 0; j--) { if (v[hash][j].first ==res) { return m * k - v[hash][j].second+ak; } } } } return -1; } 大部分 BSGS 题都很明显，随便挑了几道 P4884 多少个 1？ 原题展现 题目描述 给定整数 KKK 和质数 mmm，求最小的正整数 NNN，使得 11⋯111\\cdots 111⋯1（NNN 个 111）≡K(modm)\\equiv K \\pmod m≡K(modm)。 说人话：就是 111⋯1111 mod m=K111\\cdots 1111 \\bmod m = K111⋯1111modm=K。 输入格式 第一行两个整数，分别表示 KKK 和 mmm。 输出格式 一个整数，表示符合条件最小的 NNN。 样例 #1 样例输入 #1 9 17 样例输出 #1 3 提示 30%30\\%30% 的数据保证 m≤106m\\leq 10^6m≤106。 60%60\\%60% 的数据保证 m≤5×107m\\leq 5\\times 10^7m≤5×107。 100%100\\%100% 的数据保证 6≤m≤10116\\leq m\\leq 10^{11}6≤m≤1011，0&lt;K&lt;m0&lt; K&lt; m0&lt;K&lt;m，保证 mmm 是质数。 解法 将式子乘九，再加一，得到一个式子 10N+1=9∗k+1(mod m)10^{N+1}=9*k+1(mod\\; m) 10N+1=9∗k+1(modm) 然后 BSGS 即可 [SDOI2013] 随机数生成器 原题展现 题目背景 小 W 喜欢读书，尤其喜欢读《约翰克里斯朵夫》。 题目描述 最近小 W 准备读一本新书，这本书一共有 ppp 页，页码范围为 0∼p−10 \\sim p-10∼p−1。 小 W 很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用 NOI2012 上学习的线性同余法生成一个序列，来决定每天具体读哪一页。 我们用 xix_ixi​ 来表示通过这种方法生成出来的第 iii 个数，也即小 W 第 iii 天会读哪一页。这个方法需要设置 333 个参数 a,b,x1a,b,x_1a,b,x1​，满足 0≤a,b,x1&lt;p0\\leq a,b,x_1\\lt p0≤a,b,x1​&lt;p，且 a,b,x1a,b,x_1a,b,x1​ 都是整数。按照下面的公式生成出来一系列的整数： xi+1≡a×xi+b(modp)x_{i+1} \\equiv a \\times x_i+b \\pmod p xi+1​≡a×xi​+b(modp) 其中 mod \\bmodmod 表示取余操作。 但是这种方法可能导致某两天读的页码一样。 小 W 要读这本书的第 ttt 页，所以他想知道最早在哪一天能读到第 ttt 页，或者指出他永远不会读到第 ttt 页。 输入格式 本题单测试点内有多组测试数据。 第一行是一个整数 TTT，表示测试数据组数。 接下来 TTT 行，每行有五个整数 p,a,b,x1,tp, a, b, x_1, tp,a,b,x1​,t，表示一组数据。 输出格式 对于每组数据，输出一行一个整数表示他最早读到第 ttt 页是哪一天。如果他永远不会读到第 ttt 页，输出−1-1−1。 样例 #1 样例输入 #1 3 7 1 1 3 3 7 2 2 2 0 7 2 2 2 1 样例输出 #1 1 3 -1 提示 对于全部的测试点，保证： 1≤T≤501 \\leq T \\leq 501≤T≤50。 0≤a,b,x1,t&lt;p0 \\leq a, b, x_1, t \\lt p0≤a,b,x1​,t&lt;p，2≤p≤1092 \\leq p \\leq 10^92≤p≤109。 ppp 为质数。 解法 推式子，我还没做，等几天吧... ","tags":[{"index":-1,"name":"算法总结","slug":"Algorithm","used":true,"link":"https://Deng-Duck.github.io/tag/Algorithm/"}],"title":"浅谈BSGS和EXBSGS","feature":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F0ddace757ef68ab4d1ef7650cf949cb506e389e9.png&refer=http%3A%2F%2Fi0.hdslb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1663501361&t=abb2f09dd212ee3c62af2a74c044f50c","link":"https://Deng-Duck.github.io/post/qian-tan-bsgs-he-exbsgs/","stats":{"text":"11 min read","time":636000,"words":2251,"minutes":11},"date":"2022-05-28 19:40:31","dateFormat":"2022-05-28"},{"content":"Tampermonkey 是一款免费的浏览器扩展和最为流行的用户脚本管理器 在我们学习的过程中，往往想要更多功能 这时候可以使用 TamperMonkey 插件进行美化 Part 1: TamperMonkey 插件 Part 1.1 安装 Tampermonkey Chrome 需要用国内一些小型插件下载站，如：This 请注意个人电脑安全 其他浏览器在软件商店下载，以 Firefox 为例 打开软件商店，This 搜索 Tampermonkey ，下载安装 Part 1.2 对比 Tampermonkey 和 Stylus 大家可能也用过 Stylus美化Luogu，那么两者有什么区别吗？ 代码不兼容（ TamperMonkey 是 JS ,Stylus 是 CSS） Tampermonkey 实现插件较多， Stylus实现美化较多 Tampermonkey &gt; Stylus Tampermonkey 插件的兼容性不如 Stylus 最后一个结论是本人在 Windows 和 Linux 上测试得到的 推荐三个插件 好了，这里推荐三个 Luogu 的插件，都是工具性的 Luogu Search AnyWhere 研发者：tiger2005 最近出品的洛谷搜索引擎，比原来的搜索引擎强大很多 插件下载地址——This 点击上方红圈的**“放大镜”**图例，就可以使用了 如果你没有下载，你会看到一个小小的框子，让你输入题号 但是如果下载成功，就会看到 的界面，就可以搜索力！ 可以搜索用户，搜索题目，搜索帖子 效果图 非常方便我们搜索！ Luogu Tasks 研发者：__ OwO __ 下载链接——This 下载之后，可以在题目界面看见做题助手 你需要用一个题单支撑它，在设置-本地题单输入一个题单号 如图已经配置好了 然后就可以使用了！ 你看，不错吧，非常方便！ 但是，如果添加题需要回到题单一个一个加十分麻烦 可以用助手右上方的添加至列表，快速添加 或者在上图的添加按钮添加 快来试试吧！ Extend-Luogu 制作者：optimize_2 一个被官方半承认的插件！ 不过这个主要是娱乐性的， 下载链接——This 你可以新建一个重现赛 错过了一次比赛，想像真的打比赛一样完成吗 你可以新建一个重现赛！ 你需要输入开始时间 注意：原理是新建一个比赛，所以题目不公开就无法新建 自动填充验证码 帖子等自动填充验证码，有可能错误，但多来一次就可以了 非常舒服 鸣谢 Tothetime_tolife 犇犇指出了链接挂掉 ppip 犇犇补充了 TamperMonkey 是 JS 代码 ","tags":[{"name":"Gridea","slug":"rNPEneU98","used":true,"link":"https://Deng-Duck.github.io/tag/rNPEneU98/"}],"title":"推荐三个好用的TamperMonkey洛谷插件","feature":"https://img.tt98.com/d/2020/2020061918007893/5eec88cebaeda.jpg","link":"https://Deng-Duck.github.io/post/tui-jian-san-ge-hao-yong-de-tampermonkey-luo-gu-cha-jian/","stats":{"text":"3 min read","time":140000,"words":656,"minutes":3},"date":"2022-05-19 14:22:39","dateFormat":"2022-05-19"},{"content":"因为是线上，所以没得游记 Day 0 GDOI真奇怪，下载一堆奇奇怪怪的东西，因此换成了windows,配置了半天vscode 下午的信心赛打成泄气赛了，初一第四 T4用树的直径的思想做的，寄了 T6简单循环题思路错误，又想到分解了 我发现每次想到分解必出事是吧（NOI ONLINE的数学游戏也想成分解了，0分） T8就是经典的模的循环问题，没打完 T7和T9是水分的 Day 1 完全爆炸，每一道AC的 T1没有判 A=B=C=0A=B=C=0A=B=C=0 的情况 T2想错了，其实就是一个简单的前缀异或 T3打了一个 O(n2)O(n^2)O(n2) 的树形DP T4水分的 听完讲解觉得自己是世界上最大的SB 好吧，将一切希望寄托于Day2 经过一次实战，掌握了这个比赛的出题方向 Day 2 成绩出来了！210！还算可以吧..... 100+0+50+60 不是，为什么T2挂了啊，虽然想错了但不至于0分吧..... T3T4比想象中的分高，好耶! 排名174左右 Day2尝试逆风翻盘 T1看两眼就切了，不就是同余吗，然后就写挂了... 哦，原来是 k=0(modn)k=1(modn)k=2(modn)k=0(mod n)\\\\ k=1(mod n)\\\\ k=2(mod n)\\\\ k=0(modn)k=1(modn)k=2(modn) 得 k=0(modn)k−1=0(modn)k−2=0(modn)k=0(mod n)\\\\ k-1=0(mod n)\\\\ k-2=0(mod n)\\\\ k=0(modn)k−1=0(modn)k−2=0(modn) 啊，那没事了，我写成加一减一了，改了就切了 T2照着样例模拟了一遍就想到正解了，返回有点难搞，哦，没用啊，那没事了 T3是什么垃圾烂题，u1s1，真的出的没水平， 差不多半个小时求完常数，糊了一个代码，希望得分 T4糊了一个O(nm∣S∣)O(nm|S|)O(nm∣S∣)的DP 附一下DP代码 for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;=ss;j++) { f[i][0][ss]=1; f[i][m+1][ss]=1; } } for(int i=1;i&lt;=m;i++) { for(int j=0;j&lt;=ss;j++) { f[0][i][ss]=1; f[n+1][i][ss]=1; } } for(int i=ss-1;i&gt;=0;i--) { for(int x=1;x&lt;=n;x++) { for(int y=1;y&lt;=m;y++) { f[x][y][i]=f[x][y][i+1]; if(s[i]=='W'&amp;&amp;mp[x-1][y]==0) { f[x][y][i]|=f[x-1][y][i+1]; } if(s[i]=='S'&amp;&amp;mp[x+1][y]==0) { f[x][y][i]|=f[x+1][y][i+1]; } if(s[i]=='A'&amp;&amp;mp[x][y-1]==0) { f[x][y][i]|=f[x][y-1][i+1]; } if(s[i]=='D'&amp;&amp;mp[x][y+1]==0) { f[x][y][i]|=f[x][y+1][i+1]; } } } } 比赛结束，中午出去吃饭，高兴坏了 T1的做法的教授是一样的，应该没问题 T2教授和我的结论不一样，他说是n+Leaves Numbern+Leaves\\;Numbern+LeavesNumber, Leaves NumberLeaves\\;NumberLeavesNumber是叶子节点的个数 我说结论不对，应该是贪心，他看我代码，发现其实我们两个是一样的，nice T3我常数调对了，实现不知道怎么样，听前缀和做法好短啊，60行，我接近300行了 T3代码见后面的附录 T4的DP我的是O(nm∣S∣)O(nm|S|)O(nm∣S∣)的啊，正确性没问题吧 HZX大佬说老师讲了，但我摸鱼没听到，呵呵呵 总结 分数 100+0+50+60+100+100+40+0=450100+0+50+60+100+100+40+0=450 100+0+50+60+100+100+40+0=450 太失望了！ 排名 Day1 174Day2 154 Up 20\\texttt{Day1}\\;\\texttt{174}\\\\ \\texttt{Day2}\\;\\texttt{154}\\;\\color{red}{\\texttt{Up 20}} Day1174Day2154Up 20 没记清楚，差不多这样 希望以后加强思维吧，这次有150150150分都是不该丢的 Day1题解 T1 邹忌讽齐王纳谏 打卡题，建议模拟 建议使用map,时间复杂度为O(nlogn)O(nlogn)O(nlogn) 特判注意数据—— 0≤A,B,C0 \\leq A,B,C 0≤A,B,C 需要特判为0的情况 T2 数列游戏 首先求出前缀异或和，sum1,sum2,sum3,.....sumnsum_1,sum_2,sum_3,.....sum_nsum1​,sum2​,sum3​,.....sumn​， 如果一个区间[l,r][l,r][l,r]异或和为0，那么sumr⊕suml−1=0sum_r⊕sum_{l-1}=0sumr​⊕suml−1​=0 移项得sumr=suml−1sum_r=sum_{l-1}sumr​=suml−1​ 特别注意——如果sumx=0sum_x=0sumx​=0，那就已经可以筛掉xxx了 因此问题是在这些前缀异或和求有多少个不为0的不同的数 T3 流水线 堆优化贪心，一开始m=1m=1m=1(在1上) 随mmm的变大，每次往下加入节点，让max(w1,w2,⋅⋅⋅,wm)max(w_1, w_2, · · · , w_m)max(w1​,w2​,⋅⋅⋅,wm​)尽可能小， 求出过程中的最小值就是答案 也可以使用二分，线段树 这个正确性十分显然 T4 小学生计数题 枚举数字和公差的做法可以拿到60分 蒟蒻也不会，求讲解 大概是求出一整条链，在当中取部分的方案数，使用前缀积+区间逆元解决 希望有犇犇在评论区补充 Day2题解 T1点指兵兵 我们设有xxx个物品，那么最后会指到n mod xn\\;mod\\;xnmodx 根据题意，我们不能让n≡0,1,2(mod x)n\\equiv0,1,2(mod\\;x)n≡0,1,2(modx) 根据同余的可减性，我们得到 n≡0(mod x)n−1≡0(mod x)n−2≡0(mod x)n\\equiv0(mod\\; x)\\\\ n-1\\equiv0(mod\\; x)\\\\ n-2\\equiv0(mod\\; x)\\\\ n≡0(modx)n−1≡0(modx)n−2≡0(modx) 现在很明显了，如果不想让n≡0,1,2(mod x)n\\equiv0,1,2(mod\\;x)n≡0,1,2(modx)，那这个xxx不是n,n−1,n−2n,n-1,n-2n,n−1,n−2的因子 我们可以用O(n)O(\\sqrt{n})O(n​)的复杂度求出三者的因子数量 根据同余性质，是不可能出现重复的，不需要容斥，直接区间-部分即可 ans=n−3+1−n的因子数量−(n−1)的因子数量−(n−2)的因子数量ans=n-3+1-n的因子数量-(n-1)的因子数量-(n-2)的因子数量 ans=n−3+1−n的因子数量−(n−1)的因子数量−(n−2)的因子数量 T2网页浏览 首先不需要返回操作，替换+返回=新建+删除，后者操作性更强 然后，对于一棵树，最优显然是前几个儿子新建，最后一个儿子替换 因为一个网页只有一个父亲，在所有儿子被访问之前，爸爸不能死 但最后一个儿子被访问后，爸爸就可有可无了，这时候使用替换步数更少 对于下面的叶子结点，除了访问，还要删除 我们不难得出一个结论，answer=n+Leaves Numberanswer=n+Leaves\\;Numberanswer=n+LeavesNumber, Leaves NumberLeaves\\;NumberLeavesNumber是叶子节点的个数 因为使用上述方案，每个结点恰好被访问一次，有儿子的节点被最后一个儿子替换，而叶子节点还需要删除自己 所以就是上面的式子了 T3 教室的电子钟 思路非常简单，做法很多，但题目很恶心 最好的做法是六十行的前缀和做法 记录0年1月1日0时0分0秒到xxx年yyy月zzz日aaa时bbb分ccc秒一共消耗了多少单位的电为AAA 记录0年1月1日0时0分0秒到x’x’x’年y’y’y’月z’z’z’日a’a’a’时b’b’b’分c′c&#x27;c′秒一共消耗了多少单位的电为BBB ans=B−A ans=B-A ans=B−A 比本蒟蒻近300行对错未知的做法好多了 T4 机器人 正解是迪杰斯特拉最短路，蒟蒻没听懂 蒟蒻利用一个三维DP得到了大概50分（成绩没出） ","tags":[{"index":-1,"name":"比赛游记","slug":"BigContest","used":true,"link":"https://Deng-Duck.github.io/tag/BigContest/"},{"index":-1,"name":"比赛总结","slug":"Contest","used":true,"link":"https://Deng-Duck.github.io/tag/Contest/"}],"title":"2022广东省选普及组没的游记","feature":"https://s1.imagehub.cc/images/2022/08/20/imagec3de7949660faad3.png","link":"https://Deng-Duck.github.io/post/2022-guang-dong-sheng-xuan-pu-ji-zu-mei-de-you-ji/","stats":{"text":"9 min read","time":497000,"words":1929,"minutes":9},"date":"2022-04-19 12:33:42","dateFormat":"2022-04-19"},{"content":"这道题很有意思，运用应用了球同盒异可为空模型 而且还套了一层容斥原理，不好想 题面描述 JYY 带队参加了若干场ACM/ICPC 比赛，带回了许多土特产，要分给实验室的同学们。 JYY 想知道，把这些特产分给N 个同学，一共有多少种不同的分法？ 当然，JYY 不希望任何一个同学因为没有拿到特产而感到失落，所以每个同学都必须至少分得一个特产。 例如，JYY 带来了2 袋麻花和1 袋包子，分给A 和B 两位同学，那么共有4 种不同的 分配方法： A：麻花，B：麻花、包子 A：麻花、麻花，B：包子 A：包子，B：麻花、麻花 A：麻花、包子，B：麻花 球同盒异可为空模型 这是一个比较经典的模型了，解法非常巧妙，也就是大名鼎鼎的 Cn+m−1m−1C_{n+m-1}^{m-1} Cn+m−1m−1​ 知道的大佬可以跳过了，现在简单讲一下 因为球同，所以使用插板法，但是盒又可以空，两个板总要有什么隔着，所以现在每个盒子放一个球 球同盒异不可为空的插板公式为 Cn−1m−1C_{n-1}^{m-1} Cn−1m−1​ 在箱子放了mmm个球，所以是 Cn+m−1m−1C_{n+m-1}^{m-1} Cn+m−1m−1​ 本题思路 因为本题球有同有异,所以没有公式可以套，但如果将强制xxx人无法选择变成至少xxx人，就相对简单了 那好,至少xxx人,如何求解？ 首先，将这xxx人的组合可能求出来： CnxC_n^x Cnx​ 对于每种特产的分配，都是球同盒异可为空模型，所以是 Πi=1mCai+n−x−1n−x−1\\Pi_{i=1}^{m}C_{a_i+n-x-1}^{n-x-1} Πi=1m​Cai​+n−x−1n−x−1​ 所以对于至少xxx人无法选择 ans=Πi=1mCai+n−x−1n−x−1ans=\\Pi_{i=1}^{m}C_{a_i+n-x-1}^{n-x-1} ans=Πi=1m​Cai​+n−x−1n−x−1​ 设至少xxx人无法选择的方案数为fxf_xfx​,如何求强制xxx人无法选择？ 根据容斥原理，得 ans=f0−f1+f2.....ans=f_0-f_1+f_2..... ans=f0​−f1​+f2​..... ans=∑i=0n(−1)nfians=\\sum_{i=0}^{n}{(-1)}^nf_i ans=i=0∑n​(−1)nfi​ End P.S.：数据很水，组合数请使用杨辉三角 ","tags":[{"index":-1,"name":"题目解法","slug":"Answer","used":true,"link":"https://Deng-Duck.github.io/tag/Answer/"}],"title":"JSOI2011分特产题解","feature":"https://s1.imagehub.cc/images/2022/08/20/22055166a847a1a942021103d5579313.jpg","link":"https://Deng-Duck.github.io/post/jsoi2011-fen-te-chan-ti-jie/","stats":{"text":"3 min read","time":147000,"words":601,"minutes":3},"date":"2022-04-14 08:48:24","dateFormat":"2022-04-14"},{"content":"NOI ONLINE之前临时抱佛脚 好耶！洛谷账号橙了！ 水题 [NOI Online #2 入门组] 未了 这就是一道贪心+二分查找,思路很好想 除法有精度问题，建议不使用除法 code [NOI Online #3 提高组] 水壶 不难发现最优解一定是一个m+1m+1m+1大的区间，问题变成静态区间和 轻轻松松O(n)O(n)O(n)解决 code [NOI Online #3 入门组] 最急救助 字符串水题，直接一个一个字符看（顺便看后两个） 模拟的时间复杂度只有O(n)O(n)O(n) 其实可以加强成KMP的题 code [NOI Online #1 入门组] 文具订购 首次提交只有85，这个水题竟然有坑，奇耻大辱！ 首先应该枚举什么？套数，3元，和4元，为什么？枚举套数快，然后为了买的更多，先枚举3元的 然后倒着枚举，这样第一次求出的就是最优解 code [NOI Online #3 入门组] 观星 先整理星座，然后用一个桶（建议加一个set）存储，最后整理星系，输出 就是一道dfs+模拟，其实本质是一道普及题加上一个普及题（两个部分），但是细节很恶心,容易打错 （xuxiaobin也这么认为） code 较难题 [NOI Online 2021 入门组] 切蛋糕 NOI Online 2021 入门组我其实参加了，但是那时我还是个蒟蒻（现在也是） 当时是拿了100分，也就是只Accepted了本题 本题是一道分类讨论，有一定思维难度，一个一个情况找就对了 code [NOI Online #3 入门组] 买表 读完题很容易发现是多重背包 考虑到 kik_iki​ 很大，要用二进制优化 就当复习了 code [NOI Online #2 提高组] 涂色游戏 一道数学题，一开始没管互质只有40分，后来重推+卡常才Accepted code 变态题 [NOI Online #1 入门组] 魔法 这是入门组的题？！！ 一开始打了一个变形SPFA，但是无法保存魔法，只能使用一次，只拿到50分 正解是矩阵快速幂优化动态规划，我直接放弃，不做了 50pts code ","tags":[{"index":-1,"name":"题目解法","slug":"Answer","used":true,"link":"https://Deng-Duck.github.io/tag/Answer/"}],"title":"随便做做NOI ONLINE","feature":"https://s1.imagehub.cc/images/2022/08/20/a8db92b1793a9bab71a4cf7b58703060.jpg","link":"https://Deng-Duck.github.io/post/sui-bian-zuo-zuo-noi-online/","stats":{"text":"3 min read","time":124000,"words":558,"minutes":3},"date":"2022-03-29 08:41:34","dateFormat":"2022-03-29"},{"content":"初一第一 一般，最后一题没打好 不难发现，教练出水了，可能是信心赛 A.不幸的7 暴力，没有逻辑可言 #include&lt;bits/stdc++.h&gt; using namespace std; int n,ans,t,k; bool pd(int x) { while(x) { if(x%10==7)return false; x/=10; } return true; } int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { k=i,t=0; while(k) { t*=10; t+=k%8; k/=8; } if(pd(i)&amp;&amp;pd(t))ans++; } cout&lt;&lt;ans; } 一些没用的感想 不难发现可以优化，完全不需要存下八进制 本题考察进制转换，不AC就该反思 B.选举 简单的贪心，思路很水，五分钟想出来 先固定A，问题变成让B追上A A和B的初始的距离是什么？ sumA=∑i=1naisumA=\\sum_{i=1}^{n}a_i sumA=i=1∑n​ai​ 如果B什么都不做，A可以获得所有A支持者的选票 那一个城市能缩小多少距离呢 wi=bi+2aiw_i=b_i+2a_i wi​=bi​+2ai​ 首先，去一个城市，B的支持者和A的支持者都支持B，就是bi+aib_i+a_ibi​+ai​, A少了aia_iai​个支持者，也加上去，就这样 #include&lt;bits/stdc++.h&gt; using namespace std; struct node { long long a,b; }a[1000005]; long long n,suma,k; bool cmp(node x,node y) { return x.a*2+x.b&gt;y.a*2+y.b; } int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { scanf(&quot;%lld%lld&quot;,&amp;a[i].a,&amp;a[i].b); suma+=a[i].a; } sort(a+1,a+n+1,cmp); while(suma&gt;=0) { k++; suma-=a[k].a*2+a[k].b; } cout&lt;&lt;k; } 关于真实的题目 其实没什么 真的 开long long!,scanf! C. 差的绝对值之和 这道题水炸了，好好想，很有意思，不要直接看题解！ 题解 先排序，按绝对值的性质，从大边累加边算，看看代码吧 #include &lt;bits/stdc++.h&gt; using namespace std; long long n, a[1000005], sum, ans; int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; } sort(a + 1, a + n + 1); sum = a[n]; for (int i = n - 1; i &gt;= 1; i--) { ans += sum - a[i] * (n - i); sum += a[i]; } cout &lt;&lt; ans; } 有一个易错点，ans += sum - a[i] * (n - i);不要打成ans += sum - a[i] ;， 这个数要和前面所有数计算 D. 路径通过 整体操作，先明确父子关系，然后对于每个操作，理解为对整个树和子树的操作， 最后的dfs统计即可 #include&lt;bits/stdc++.h&gt; using namespace std; struct node { int t,next; }a[500005]; long long n,m,x,y,z,tot,h[500005],fa[500005],s[500005],t[500005],w[500005],ans[500005]; void add(int x,int y) { tot++; a[tot].t=y; a[tot].next=h[x]; h[x]=tot; } void dfa(int x,int f) { for(int i=h[x];i;i=a[i].next) { if(a[i].t!=f) { fa[a[i].t]=x; dfa(a[i].t,x); } } } void dfs(int x,int f) { ans[x]=ans[f]+w[x]; for(int i=h[x];i;i=a[i].next) { if(a[i].t!=f) { dfs(a[i].t,x); } } } int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n-1;i++) { cin&gt;&gt;x&gt;&gt;y; add(x,y); add(y,x); s[i]=x; t[i]=y; } dfa(1,0); cin&gt;&gt;m; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; if(x==1) { if(fa[t[y]]==s[y]) { w[1]+=z; w[t[y]]-=z; } else { w[s[y]]+=z; } } else { if(fa[t[y]]==s[y]) { w[t[y]]+=z; } else { w[1]+=z; w[s[y]]-=z; } } } dfs(1,0); for(int i=1;i&lt;=n;i++) { cout&lt;&lt;ans[i]&lt;&lt;endl; } } 另一种做法 按dfs序，变成一个数组，然后树状数组整体操作 E. 龙椅 这就是个Exgcd，我打出来真是万幸，就是找正整数解那段忘了，自己的又臭又长 s+1+xk≡1(mod n) s+1+xk \\equiv 1(mod\\ n) s+1+xk≡1(mod n) x为题目所求 化简得 xk−yn=−sxk-yn=-s xk−yn=−s 求即可 #include&lt;bits/stdc++.h&gt; using namespace std; long long t,a,b,c,x,y,gcd; void exgcd(long long a,long long b,long long &amp;x,long long &amp;y) { if(!b) { // cout&lt;&lt;a&lt;&lt;' '&lt;&lt;b&lt;&lt;endl; gcd=a; x=1; y=0; return; } exgcd(b,a%b,y,x); //cout&lt;&lt;a&lt;&lt;' '&lt;&lt;b&lt;&lt;' '&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;endl; y-=((a/b)*x); } int main() { cin&gt;&gt;t; for(int i=1;i&lt;=t;i++) { cin&gt;&gt;b&gt;&gt;c&gt;&gt;a; x=0,y=0; exgcd(a,-b,x,y); if((-c)%gcd!=0) { cout&lt;&lt;-1&lt;&lt;endl; continue; } x*=-c/gcd; y*=-c/gcd; if((a*-b)/gcd&gt;0) { y-=(a*-b)/gcd/b*(x/(a*-b)/gcd/a); x%=(a*-b)/gcd/a; while(x&lt;0) { x+=(a*-b)/gcd/a; y-=(a*-b)/gcd/b; } y+=(a*-b)/gcd/b*(x/(a*-b)/gcd/a); x%=(a*-b)/gcd/a; while(x-((a*-b)/gcd)/a&gt;=0) { x-=(a*-b)/gcd/a; y+=(a*-b)/gcd/b; } } else { y+=(a*-b)/gcd/b*(x/(a*-b)/gcd/a); x%=(a*-b)/gcd/a; while(x&lt;0) { x-=(a*-b)/gcd/a; y+=(a*-b)/gcd/b; } y-=(a*-b)/gcd/b*(x/(a*-b)/gcd/a); x%=(a*-b)/gcd/a; while(x+((a*-b)/gcd)/a&gt;=0) { x+=(a*-b)/gcd/a; y-=(a*-b)/gcd/b; } } cout&lt;&lt;x&lt;&lt;endl; } } 第六题待做 ","tags":[{"index":-1,"name":"比赛总结","slug":"Contest","used":true,"link":"https://Deng-Duck.github.io/tag/Contest/"}],"title":"2022年3月3日模拟赛总结","feature":"https://s1.imagehub.cc/images/2022/08/20/2233.jpg","link":"https://Deng-Duck.github.io/post/20220303/","stats":{"text":"7 min read","time":385000,"words":1207,"minutes":7},"date":"2022-03-03 08:09:06","dateFormat":"2022-03-03"},{"content":"其实这道题不难，作者出成了小模拟 输入也可以利用sscanf解决 题目链接 题目分析 map不会冲突！！不一定要like代码中那样加-号！ 模拟，算不上大, 首先，我们想想整个流程: 现在，我们找出难点，逐个瓦解: 读入提取数 MIDDLE 非法情况判断 HARD 是否重复 EASY 从简到难解决。 是否重复 首先，将5个数字按次序组合成一个大数， 本人测试：25525525525565535是long long存的下的， 然后map搞定。 就解决了，参考代码： long long sum=0; sum+=a; sum*=1000; sum+=b; sum*=1000; sum+=c; sum*=1000; sum+=d; sum*=100000; sum+=e;//转换 if(s==&quot;Server&quot;) { if(m[-sum]) { cout&lt;&lt;&quot;FAIL&quot;&lt;&lt;endl; continue; } m[-sum]=T;//记录这个服务机的编号，后边客户机要用 cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl; } else { if(!m[-sum]) { cout&lt;&lt;&quot;FAIL&quot;&lt;&lt;endl; continue; } cout&lt;&lt;m[-sum]&lt;&lt;endl;//输出服务机的编号 } 读入提取数 怎么提取数字呢? 其实也不难, scanf支持格式输入, 如 scanf(&quot;%d.%d.%d.%d:%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e) 输入 1.1.1.1:1 a=1,b=1,c=1,d=1,e=1a=1,b=1,c=1,d=1,e=1a=1,b=1,c=1,d=1,e=1 如果不按格式？ 1:1:1:1.1 a=1,b=0,c=0,d=0,e=0a=1,b=0,c=0,d=0,e=0a=1,b=0,c=0,d=0,e=0 What?不按格式的部分值没有变化？ 问题三有头绪了呢.... 非法情况判断 通过如上方案，我们将五个数初始化为-1, 如果格式输入后有-1，那格式有误，非法。 参考代码： a=-1,b=-1,c=-1,d=-1,e=-1; cin&gt;&gt;s; scanf(&quot;%d.%d.%d.%d:%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e); if(a==-1||b==-1||c==-1||d==-1||e==-1) { cout&lt;&lt;&quot;ERR&quot;&lt;&lt;endl; continue; } 同样的，判断数字是否超出范围： if(a&gt;255||b&gt;255||c&gt;255||d&gt;255||e&gt;65535) { cout&lt;&lt;&quot;ERR&quot;&lt;&lt;endl; continue; } 你可能会问，如果输入了一个巨大的数， long long溢出，怎么办？ 别急，我们往下看。 前导零问题如何解决？？ 我们想想，因为前导零被变量“吃”了， 现在的字符串一定比之前的字符串短， 我们判断即可。 怎么存下之前的字符串？ 使用sscanf sscanf不同于scanf,它需要多一个字符串参数 相当于用scanf将字符串内容读了一遍， 读入效果与scanf一样 这样，我们先读入一个字符串， 然后sscanf读入， 这样两个结果都存了下来， 鱼和熊掌的兼得。 a=-1,b=-1,c=-1,d=-1,e=-1; cin&gt;&gt;s; cin&gt;&gt;cc;//sscanf的妙用 sscanf(cc,&quot;%d.%d.%d.%d:%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e); if(a==-1||b==-1||c==-1||d==-1||e==-1) { cout&lt;&lt;&quot;ERR&quot;&lt;&lt;endl; continue; } if(a&gt;255||b&gt;255||c&gt;255||d&gt;255||e&gt;65535) { cout&lt;&lt;&quot;ERR&quot;&lt;&lt;endl; continue; } if(len(a)+len(b)+len(c)+len(d)+len(e)+4!=strlen(cc)) {//len是一个判断数字长度的自定义函数 //+4是四个标点符号 cout&lt;&lt;&quot;ERR&quot;&lt;&lt;endl; continue; } 其实，非法情况就都可以判走了， 因为 前导零、整数超出、格式错误被判掉。 多个数字显然长度不等。 long long 溢出，长度变小了。 好了，这道题其实不难，重点在函数使用的基本功。 参考代码 #include&lt;bits/stdc++.h&gt; using namespace std; map&lt;long long,int&gt; m; int n,a,b,c,d,e; string s,s2; char cc[105]; int len(int x) { if(x==0)return 1; int ans=0; while(x) { ans++; x/=10; } return ans; } int main() { cin&gt;&gt;n; for(int T=1;T&lt;=n;T++) { a=-1,b=-1,c=-1,d=-1,e=-1; cin&gt;&gt;s; cin&gt;&gt;cc; sscanf(cc,&quot;%d.%d.%d.%d:%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e); if(a==-1||b==-1||c==-1||d==-1||e==-1) { cout&lt;&lt;&quot;ERR&quot;&lt;&lt;endl; continue; } if(a&gt;255||b&gt;255||c&gt;255||d&gt;255||e&gt;65535) { cout&lt;&lt;&quot;ERR&quot;&lt;&lt;endl; continue; } if(len(a)+len(b)+len(c)+len(d)+len(e)+4!=strlen(cc)) { cout&lt;&lt;&quot;ERR&quot;&lt;&lt;endl; continue; } long long sum=0; sum+=a; sum*=1000; sum+=b; sum*=1000; sum+=c; sum*=1000; sum+=d; sum*=100000; sum+=e; if(s==&quot;Server&quot;) { if(m[-sum]) { cout&lt;&lt;&quot;FAIL&quot;&lt;&lt;endl; continue; } m[-sum]=T; cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl; } else { if(!m[-sum]) { cout&lt;&lt;&quot;FAIL&quot;&lt;&lt;endl; continue; } cout&lt;&lt;m[-sum]&lt;&lt;endl; } } } ","tags":[{"index":-1,"name":"题目解法","slug":"Answer","used":true,"link":"https://Deng-Duck.github.io/tag/Answer/"}],"title":"2021CSP-J网络连接题解","feature":"https://s1.imagehub.cc/images/2022/08/20/0dd9b72e672c3b4b3886ef8f8dd027e7.jpg","link":"https://Deng-Duck.github.io/post/2021csp-j-wang-luo-lian-jie-ti-jie/","stats":{"text":"6 min read","time":334000,"words":1134,"minutes":6},"date":"2021-11-18 21:15:09","dateFormat":"2021-11-18"},{"content":"这次考的是思维题,只做出了雨水 思维不够敏捷，要练 第一题：0 第二题：31（最高分56） 第三题：100 第四题：5 总分：136 排名：19 赛后AK 凑数2526 题义： 一个长度为n+m+kn+m+kn+m+k，包含nnn个数字222，mmm个数字555和kkk个数字666的序列，最多可能有多少个子序列是252625262526？ 如果一个序列是数组的子序列，当且仅当这个序列可以由数组删去任意个元素，再将数组中的剩余元素按顺序排列而成。 推导： 思维题，若想最大，要均分nnn，n/2n/2n/2和a−n/2a-n/2a−n/2 比赛时想成排列组合了，Zero 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int main() { long long t,a,b,c; scanf(&quot;%lld&quot;,&amp;t); for(int i=1;i&lt;=t;i++) { scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c); printf(&quot;%lld\\n&quot;,(a/2)*(a-a/2)*b*c); } } 以后要好好分析，不要想复杂 最小乘积 题义： 在区间[L,R][L,R][L,R]中找两个不同的数，使得它们的乘积模2019最小 推导： 同样是水题 如果r−l&gt;2019r-l &gt;2019r−l&gt;2019,中间必然有201920192019的倍数，输出0 然后直接枚举2019∗20192019*20192019∗2019不会爆， 比赛时的错误太羞耻了，过过过 代码： #include &lt;bits/stdc++.h&gt; using namespace std; long long l, r, mn=1e11; int main() { cin &gt;&gt; l &gt;&gt; r; if (r - l &gt;= 2017 ) { cout &lt;&lt; 0 &lt;&lt; endl; return 0; } for (long long i = l; i &lt;= r; i++) { for (long long j = i + 1; j &lt;= r; j++) { mn = min(mn, i % 2019 * j % 2019); } } cout &lt;&lt; mn &lt;&lt; endl; } 雨水 题义： 有nnn座山成环，nnn是奇数,两座山之间有一个水坝。 第iii座山和第i+1i+1i+1座山之间的水坝称为第i个水坝。 第n+1n+1n+1座山也是第111座山，第n+1n+1n+1个水坝也是第111个水坝。 如果第i座山降雨量为fif_ifi​，则它的降雨量会平均地分到相邻两座水坝去。 假设水坝的水全是由山上的降雨提供。 现在给出每一座水坝收到的水量，问每座山的降雨量。 推导： aaa已知，fff未知 根据题义得 ai=(fi+fi+1)/2a_i=(f_i+f_{i+1})/2 ai​=(fi​+fi+1​)/2 交换得 2∗ai=(fi+fi+1)2*a_i=(f_i+f_{i+1}) 2∗ai​=(fi​+fi+1​) 则 fi=2∗ai−fi+1f_i=2*a_i-f_{i+1} fi​=2∗ai​−fi+1​ 然后是重头戏 因为公式中有个未知数代码，要求nnn个公式，肯定不能For 能不能没有未知数？ 以n=3n=3n=3为例，我们尝试消除未知数 求 f1f_1f1​ 时，将 f2f_2f2​ 的算式带入，求 f2f_2f2​ 时,将f3f_3f3​的算式带入 得 f1=2∗a1−2∗a2+2∗a3−f1f_1=2*a_1-2*a_2+2*a_3-f_1 f1​=2∗a1​−2∗a2​+2∗a3​−f1​ 得 2f1=2∗a1−2∗a2+2∗a32f_1=2*a_1-2*a_2+2*a_3 2f1​=2∗a1​−2∗a2​+2∗a3​ 得 f1=a1−a2+a3f_1=a_1-a_2+a_3 f1​=a1​−a2​+a3​ Great! 推出其他未知数 有了f1f_1f1​ 我们可以推出其他未知数 先推出 fnf_nfn​,再倒退其他 代码： 先求f1f_1f1​ 根据上面的公式,奇数加，偶数减 for(int i=1;i&lt;=n;i++) { if(i%2==1) { f[1]+=a[i]; } else { f[1]-=a[i]; } } 求fnf_nfn​,倒退 f[n]=2*a[n]-f[1]; for(int i=n-1;i&gt;=1;i--) { f[i]=2*a[i]-f[i+1]; } 完整代码 #include&lt;bits/stdc++.h&gt; using namespace std; long long n,a[100005],f[100005]; int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; } for(int i=1;i&lt;=n;i++) { if(i%2==1) { f[1]+=a[i]; } else { f[1]-=a[i]; } } f[n]=2*a[n]-f[1]; for(int i=n-1;i&gt;=1;i--) { f[i]=2*a[i]-f[i+1]; } for(int i=1;i&lt;=n;i++) { cout&lt;&lt;f[i]&lt;&lt;' '; } } 染色： 题义： 有一棵树，包含n个点，现在你要对所有的点染色，你一共有K种颜色。 两个距离小于等于2的不同顶点，它们必须染成不一样的颜色。 问有多少种染色的方案 推导： DFS即可，实现难，但是思路还是很水的，直接模拟 代码： 请认真看批注！！ #include&lt;bits/stdc++.h&gt; using namespace std; struct node { long long t,next;//前向星 }a[1000005]; long long n,k,x,y,t,h[1000005],b[1000005],flag,ans=1; void add(int x,int y)//加边 { t++; a[t].t=y; a[t].next=h[x]; h[x]=t; } void dfs(int x,int y,int z) { ans*=k-y-z;//乘上可选方案数 ans%=1000000007; int t=0;//表示兄弟数 b[x]=1;//b表示是否到达过 for(int i=h[x];i&gt;0;i=a[i].next) { if(b[a[i].t]==0) { if(y+1&lt;=2)//如果不是根或根的儿子，y=2，否则y+1 { dfs(a[i].t,y+1,t); } else { dfs(a[i].t,y,t); } t++; } } } int main() { cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n-1;i++) { cin&gt;&gt;x&gt;&gt;y; add(x,y); add(y,x); } dfs(1,0,0); if(flag)//想一想，这个有什么用？ { cout&lt;&lt;0&lt;&lt;endl; return 0; } cout&lt;&lt;ans&lt;&lt;endl; } ","tags":[{"index":-1,"name":"比赛总结","slug":"Contest","used":true,"link":"https://Deng-Duck.github.io/tag/Contest/"}],"title":"2021年9月20日模拟赛总结","feature":"https://s1.imagehub.cc/images/2022/08/20/JK.png","link":"https://Deng-Duck.github.io/post/20210920/","stats":{"text":"6 min read","time":359000,"words":1253,"minutes":6},"date":"2021-09-20 20:51:28","dateFormat":"2021-09-20"},{"content":"本文讲介绍关于合并石子的做法： 区间DP，记忆化搜索和四边形不等式优化 题目大意： 设有 NNN 堆石子排成一排，其编号为 1，2，3，…，N1，2，3，…，N1，2，3，…，N 每堆石子有一定的质量，可以用一个整数来描述 现在要将这 NNN 堆石子合并成为一堆，每次只能合并相邻的两堆 合并的代价为这两堆石子的质量之和 合并后与这两堆石子相邻的石子将和新堆相邻 合并时由于选择的顺序不同，合并的总代价也不相同 找出一种合理的方法，使总的代价最小，输出最小代价 同时输出合并过程 合并石子其实和 合并果子 很像 只是合并 只能相邻，但其实也方便了 区间dp 从最后一次合并开始思考 最后一次合并前，石子肯定只有两堆 ， 设k为两者 中点 ， 也就是两堆中间的位置 第一堆是原来的111到kkk堆，第二堆是原来的第k+1k+1k+1到第nnn堆。 显然， 要使得总代价最小，必然是该两堆式子之前的合并代价最小。 然后不断拆分成子问题解决 定义状态f(i,j)f(i,j)f(i,j) 表示 第i堆石子到第j堆石子 的 最小合并代价 。 目标状态即为f(1,n)f(1,n)f(1,n)。 方程——f(i,j)=min(f(i,k)+f（k+1,j)+sum(i,j)f(i,j)=min(f(i,k)+f（k+1,j)+sum(i,j)f(i,j)=min(f(i,k)+f（k+1,j)+sum(i,j) sum是什么呢？是一个 区间和 ，我们利用 前缀和 可以将询问sum的复杂度降至 O(1) int query(int i, int j) //前缀和，sum[i],表示1~i的和，数学内容，简单，自行思考原理 { return sum[j] - sum[i - 1]; } 为什么是 区间和 呢？ 其实 区间和就是两堆的重量（简单，自行思考） 也就是 合并代价 然后是 初始化 因为是求最小值，所以要开一个大数 memset(f, 27, sizeof(f)); 27其实计算机会认为是一个很大的数，接近int边界，并不是我们认为的27 也可以换成其他数 for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; sum[i] = sum[i - 1] + a[i];// 预处理前缀和 f[i][i] = 0;//自己合并自己不需要代价 } 输入可以同时处理 见代码，sum可以求，因为自己合并自己不需要代价 ，所以f(i,i)f(i,i)f(i,i)始终为0 接下来讲解dp部分 由于我们已经知道起点和区间大小，所以可以求终点 然后枚举中点就完了 for (int k = 2; k &lt;= n; k++)//k,枚举区间大小 { 这个p是什么呢？ p数组用来记录最优解的中点 Why？ for (int i = 1; i &lt;= n; i++) //i,枚举起点 { int j = i + k - 1;//求终点 for (int l = i; l &lt; j; l++)//枚举中点，这里可以优化，详见PPT《DP之四边形不等式优化》 { if (f[i][j] &gt; f[i][l] + f[l + 1][j] + query(i, j)) //求最小值 { f[i][j] = f[i][l] + f[l + 1][j] + query(i, j); p[i][j] = l;//有新的最小值,更新中点 } } } } 这个p是什么呢？ p数组用来记录最优解的中点 Why？ 由于题目要求过程，我们可以用递归求解 这时p就派上用场了 p(i,j)p(i,j)p(i,j)表示合并i,j时的中点k 由此将l,r分成两份，不断递归 void dg(int l, int r) { if (l == r) {//说明只有一个数，直接输出！ cout &lt;&lt; a[r];//不要换行！不要空格！ return; } cout &lt;&lt; '(';//输出左右括号 int mid = p[l][r];//读取中点 dg(l, mid);//递归左半部分 cout &lt;&lt; &quot;)(&quot;;//输出中间括号 dg(mid + 1, r);//递归右半部分 cout &lt;&lt; ')';//输出左右括号 } 好了，这就是关于合并石子的全部内容了 上代码！ #include &lt;bits/stdc++.h&gt; using namespace std; int n, a[1005], f[1005][1005], p[1005][1005], sum[1005]; int query(int i, int j) { return sum[j] - sum[i - 1]; } void dg(int l, int r) { if (l == r) { cout &lt;&lt; a[r]; return; } cout &lt;&lt; '('; int mid = p[l][r]; dg(l, mid); cout &lt;&lt; &quot;)(&quot;; dg(mid + 1, r); cout &lt;&lt; ')'; } int main() { memset(f, 27, sizeof(f)); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; sum[i] = sum[i - 1] + a[i]; f[i][i] = 0; } for (int k = 2; k &lt;= n; k++) { for (int i = 1; i &lt;= n; i++) { int j = i + k - 1; for (int l = i; l &lt; j; l++) { if (f[i][j] &gt; f[i][l] + f[l + 1][j] + query(i, j)) { f[i][j] = f[i][l] + f[l + 1][j] + query(i, j); p[i][j] = l; } } } } cout &lt;&lt; f[1][n] &lt;&lt; endl; dg(1, n); return 0; } 记忆化搜索更加清晰，易于理解 (不过无法使用四边形不等式优化) 浅谈记忆化： 如果说动态规划是递推，那记忆化就是递归 它的思路是： 同动态规划，若子问题的解永远不变，再次计算便没有意义 我们将其记录在 f 数组或dp数组（命名习惯不同） 但动态规划算出了所有子问题 所以，我们用递归求解，保证只求到有用子问题 但其实因为递归实现，二者复杂度接近，动态规划较快 它的框架是： 类型 dg(参数) { if(f[参数]已经计算过)return f[参数]; if(边界)return 对应的数; //如果已经给边界初始化，可以省略 计算 f[参数]=解//保存解 return 解; } 注意！使用递归函数表示子问题！ 代码详解： memset(f,-1, sizeof(f)); n = read();//又 用 快 读 for (int i = 1; i &lt;= n; i++) { a[i] = read(); p[i][i]=i; } 输入，初始化 注意！f = -1 表示 未计算！ 前缀和略 printf(&quot;%ld\\n&quot;, dg(1, n));//输出解 dfs(1, n);//求过程 主函数完 求过程略 记忆化部分和动态规划很像，因为我们知道了起点i和终点j 所以处理完边界后，可以直接枚举中点 long dg(int i, int j) { if(i==j)return 0;//边界，自己合并自己不需要代价 if (f[i][j] != -1) //如果计算了，返回 { return f[i][j]; } f[i][j]=1E9; for (int k = i; k &lt;= j; k++) //计算 { if (f[i][j] &gt; dg(i, k) + dg(k + 1, j) + w(i, j)) //注意!用dg表示子问题！ { f[i][j] = dg(i, k) + dg(k + 1, j) + w(i, j); p[i][j] = k;//记录中点 } } return f[i][j];//返回 } 上代码： #include &lt;bits/stdc++.h&gt; using namespace std; inline int read() { int ans = 0; char c = getchar(); while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c != '-')) { c = getchar(); } ans = c - '0'; c = getchar(); while (c &gt;= '0' &amp;&amp; c &lt;= '9') { ans = (ans &lt;&lt; 3) + (ans &lt;&lt; 1) + c - '0'; c = getchar(); } return ans; } long f[105][105], p[105][105], a[105], sum[105], n, mn = 1E9; long w(long i, long j) { return sum[j] - sum[i - 1]; } void dfs(int l, int r) { if (l == r) { cout &lt;&lt; a[r]; return; } cout &lt;&lt; '('; int mid = p[l][r]; dfs(l, mid); cout &lt;&lt; &quot;)(&quot;; dfs(mid + 1, r); cout &lt;&lt; ')'; } long dg(int i, int j) { long x, y; if(i==j)return 0; if (f[i][j] != -1) { return f[i][j]; } f[i][j]=1E9; for (int k = i; k &lt;= j; k++) { if (f[i][j] &gt; dg(i, k) + dg(k + 1, j) + w(i, j)) { f[i][j] = dg(i, k) + dg(k + 1, j) + w(i, j); p[i][j] = k; } } return f[i][j]; } int main() { memset(f,-1, sizeof(f)); n = read(); for (int i = 1; i &lt;= n; i++) { a[i] = read(); p[i][i]=i; } for (int i = 1; i &lt;= n; i++) { sum[i] = sum[i - 1] + a[i]; } printf(&quot;%ld\\n&quot;, dg(1, n)); dfs(1, n); } 题目大意： 在一圆形操场四周摆放N堆石子 , 现要将石子有次序地合并成一堆. 规定每次只能选相临的两堆合并成一堆,并将新的一堆的石子数,记为该次合并的得分。 编一程序,选择一种合并石子的方案,使得做N-1次合并,得分的总和最少 但数据高达n&lt;=2500 知识讲解： 在动态规划问题中，有一个常见的状态转移方程： f(i,j)=min(f(i,k)+f(k+1,j))+w[i,j]f(i,j)=min(f(i,k)+f(k+1,j))+w[i,j]f(i,j)=min(f(i,k)+f(k+1,j))+w[i,j] 注意上面的粗体部分 min——求最小值 k——枚举的中点 w[i,j]w[i,j]w[i,j]——一个区间处理的函数（如前缀和） 这种公式就是将一个问 题 通过 一个枚举的中点将问题拆成两半，然后加上一个其他利益的计算函数 这种公式若有这三个元素，可以如下判断： w[i,j]w[i,j]w[i,j]是否满足两个性质： 1.若i&lt;i’&lt;j&lt;j’i&lt;i’&lt;j&lt;j’i&lt;i’&lt;j&lt;j’,则w[i′,j]&lt;=w[i,j′]w[i&#x27;,j]&lt;=w[i,j&#x27;]w[i′,j]&lt;=w[i,j′]——区间包含 解析 ：其实很好理解，整个区间是w[i,j′],w[i′,j]w[i,j&#x27;],w[i&#x27;,j]w[i,j′],w[i′,j]是里面的小区间，我们判断时只要看整体里的小区间是否一定小于整体区间即可 如：区间和就是一个区间包含，比如sum（1,6)sum（1,6)sum（1,6)一定大于sum(2,4)sum(2,4)sum(2,4) 2.若i&lt;i’&lt;j&lt;j’i&lt;i’&lt;j&lt;j’i&lt;i’&lt;j&lt;j’,则w(i,j)+w(i′,j′)&lt;=w(i,j′)+w（i′,j)w(i,j)+w(i&#x27;,j&#x27;)&lt;=w(i,j&#x27;)+w（i&#x27;,j)w(i,j)+w(i′,j′)&lt;=w(i,j′)+w（i′,j)——平行四边形不等式。 为什么叫平行四边形不等式？我不知道 但是我们大概记一下即可 可以证明：若w满足区间包含单调性和平行四边形不等式，则f也满足区间平行四边形不等式的性质。 不用记证明，我们记结论 设s(i,j)表示f(i,j)的最佳决策点 也就是f (i,j)为最小值时的中点k 则s满足 {​s(i−1)(j)&lt;=s(i,j)&lt;=s(i)(j+1)​s(i)(j−1)&lt;=s(i,j)&lt;=s(i+1)(j)\\begin{cases} ​ s(i-1)(j)&lt;=s(i,j)&lt;=s(i)(j+1)\\\\ ​ s(i)(j-1)&lt;=s(i,j)&lt;=s(i+1)(j) \\end{cases} {​s(i−1)(j)&lt;=s(i,j)&lt;=s(i)(j+1)​s(i)(j−1)&lt;=s(i,j)&lt;=s(i+1)(j)​ 但只适用于求min 想一想，为什么？ 答案将在树的构造的题解公布 这样，我们可以减少枚举的次数 显然，k的最优解=s(i,j)s(i,j)s(i,j) 范围缩小了 因为我们求s(i,j)s(i,j)s(i,j), 一定需要s(i−1)(j)，s(i)(j+1)s(i-1)(j)，s(i)(j+1)s(i−1)(j)，s(i)(j+1) 或者s(i)(j−1)，s(i+1)(j)s(i)(j-1)，s(i+1)(j)s(i)(j−1)，s(i+1)(j) 所以我们需要选择， 两个不等式，需一个i从大到小枚举，需一个j从大到小枚举 Ps：我们要判断s是否为零，如果为零就仍用i~j 蒟蒻讲的可能不标准，详见PPT 题目详解： 合并石子公式：f(i,j)=min(f(i,l)+f(l+1,j)+w(i,j))f(i,j)=min(f(i,l)+f(l+1,j)+w(i,j))f(i,j)=min(f(i,l)+f(l+1,j)+w(i,j)) 具有三要素 w(i,j)w(i,j)w(i,j)为区间和 满足 区间包含单调性和平行四边形不等式 可以用平行四边形不等式优化 j是由i计算的，所以使用i从大到小的 s(i)(j−1)&lt;=s(i,j)&lt;=s(i+1)(j)s(i)(j-1)&lt;=s(i,j)&lt;=s(i+1)(j)s(i)(j−1)&lt;=s(i,j)&lt;=s(i+1)(j) 代码详解： 大多数和版本二相同 输入和初始化： n=read();//又用了快读，我是有病吗？ for(int i=1;i&lt;=n;i++) { a[i]=a[i+n]=read();//输入a f[i][i]=f[i+n][i+n]=0;//初始化f s[i][i]=i;//分割自己，自己是自己的中点，故s[i][i]=i s[i+n][i+n]=i+n;//同上 } n*=2; 对了，这是个环，但做了版本二后环已经废了，就是来加大数据的 求前缀和（略） DP部分 没什么注意的 重点是i从大到小 for(int k=2;k&lt;=n/2;k++)//区间大小 { for(int i=n-k+1;i&gt;=1;i--)//从大到小枚举起点 { int j=i+k-1,x,y;//求终点 if(s[i][j-1])//如果s(i,j-1)为0，从i开始 { x=s[i][j-1]; } else { x=i; } if(s[i+1][j])//如果s(i+1,j)为0，从j结束 { y=s[i+1][j]; } else { y=j; } for(int l=x;l&lt;=y;l++)//同版本二 { if(f[i][j]&gt;f[i][l]+f[l+1][j]+w(i,j)) { f[i][j]=f[i][l]+f[l+1][j]+w(i,j); s[i][j]=l; } } } } 因为有多种可行方案，所以我们循环要找一个min for(int i=1;i&lt;=n/2;i++) { mn=min(mn,f[i][i+n/2-1]); } 输出即可 上代码： 没忍住打了个快读 #include&lt;stdio.h&gt; #include&lt;bits/stdc++.h&gt; using namespace std; inline int read() { int ans = 0; char c = getchar(); while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c != '-')) { c = getchar(); } ans = c - '0'; c = getchar(); while (c &gt;= '0' &amp;&amp; c &lt;= '9') { ans = (ans &lt;&lt; 3) + (ans &lt;&lt; 1) + c - '0'; c = getchar(); } return ans; } long f[5005][5005],s[5005][5005],a[5005],sum[5005],n,mn=1E8; long w(long i,long j) { return sum[j]-sum[i-1]; } int main() { memset(f,127,sizeof(f)); n=read(); for(int i=1;i&lt;=n;i++) { a[i]=a[i+n]=read(); f[i][i]=f[i+n][i+n]=0; s[i][i]=i; s[i+n][i+n]=i+n; } n*=2; for(int i=1;i&lt;=n;i++) { sum[i]=sum[i-1]+a[i]; } for(int k=2;k&lt;=n/2;k++) { for(int i=n-k+1;i&gt;=1;i--) { int j=i+k-1,x,y; if(s[i][j-1]) { x=s[i][j-1]; } else { x=i; } if(s[i+1][j]) { y=s[i+1][j]; } else { y=j; } for(int l=x;l&lt;=y;l++) { if(f[i][j]&gt;f[i][l]+f[l+1][j]+w(i,j)) { f[i][j]=f[i][l]+f[l+1][j]+w(i,j); s[i][j]=l; } } } } for(int i=1;i&lt;=n/2;i++) { mn=min(mn,f[i][i+n/2-1]); } printf(&quot;%d&quot;,mn); } ","tags":[{"index":-1,"name":"题目解法","slug":"Answer","used":true,"link":"https://Deng-Duck.github.io/tag/Answer/"},{"index":-1,"name":"算法总结","slug":"Algorithm","used":true,"link":"https://Deng-Duck.github.io/tag/Algorithm/"}],"title":"合并石子三讲","feature":"https://s1.imagehub.cc/images/2022/08/20/b25c0b1990e6325e331da72bcaa381ae.jpg","link":"https://Deng-Duck.github.io/post/he-bing-shi-zi-san-jiang/","stats":{"text":"17 min read","time":1012000,"words":3559,"minutes":17},"date":"2021-09-05 20:08:53","dateFormat":"2021-09-05"}]}