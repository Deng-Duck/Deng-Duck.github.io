<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>合并石子三讲 | DengDuck&#39;s Blog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://Deng-Duck.github.io/favicon.ico?v=1660867506237">
<link rel="stylesheet" href="https://Deng-Duck.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="题目大意：

设有 NNN 堆石子排成一排，其编号为 1，2，3，…，N1，2，3，…，N1，2，3，…，N
每堆石子有一定的质量，可以用一个整数来描述
现在要将这 NNN 堆石子合并成为一堆，每次只能合并相邻的两堆
合并的代价为这两堆石子..." />
    <meta name="keywords" content="题目解法,算法总结" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://Deng-Duck.github.io">
        <img src="https://Deng-Duck.github.io/images/avatar.png?v=1660867506237" class="site-logo">
        <h1 class="site-title">DengDuck&#39;s Blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      感谢大家支持DuckOI
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://Deng-Duck.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">合并石子三讲</h2>
            <div class="post-date">2021-09-05</div>
            
              <div class="feature-container" style="background-image: url('https://s1.ax1x.com/2022/08/18/vrnXkQ.jpg')">
              </div>
            
            <div class="post-content" v-pre>
              <h2 id="题目大意">题目大意：</h2>
<blockquote>
<p>设有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 堆石子排成一排，其编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">，</mi><mn>2</mn><mi mathvariant="normal">，</mi><mn>3</mn><mi mathvariant="normal">，</mi><mo>…</mo><mi mathvariant="normal">，</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">1，2，3，…，N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mord">3</span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></p>
<p>每堆石子有一定的质量，可以用一个整数来描述</p>
<p>现在要将这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 堆石子合并成为一堆，每次只能合并相邻的两堆</p>
<p>合并的代价为这两堆石子的质量之和</p>
<p>合并后与这两堆石子相邻的石子将和新堆相邻</p>
<p>合并时由于选择的顺序不同，合并的总代价也不相同</p>
<p>找出一种合理的方法，使总的代价最小，输出最小代价</p>
<p>同时输出合并过程</p>
</blockquote>
<hr>
<p>合并石子其实和 <strong>合并果子</strong><br>
很像</p>
<p>只是合并 <strong>只能相邻</strong>，但其实也方便了 <strong>区间dp</strong></p>
<p>从最后一次合并开始思考</p>
<p>最后一次合并前，<strong>石子肯定只有两堆</strong> ，</p>
<p>设k为两者 <strong>中点</strong> ， <strong>也就是两堆中间的位置</strong></p>
<p>第一堆是原来的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>堆，第二堆是原来的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>堆。</p>
<p>显然，</p>
<p>要使得总代价最小，必然是该两堆式子之前的合并代价最小。</p>
<p>然后不断拆分成子问题解决</p>
<hr>
<p>定义状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></p>
<p>表示 <strong>第i堆石子到第j堆石子</strong> 的 <strong>最小合并代价</strong> 。</p>
<p>目标状态即为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(1,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>方程——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo><mo>+</mo><mi>f</mi><mi mathvariant="normal">（</mi><mi>k</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>+</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(i,j)=min(f(i,k)+f（k+1,j)+sum(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord cjk_fallback">（</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></p>
<p>sum是什么呢？是一个 <strong>区间和</strong> ，我们利用 <strong>前缀和</strong> 可以将询问sum的复杂度降至  <strong>O(1)</strong></p>
<pre><code class="language-cpp">int query(int i, int j) //前缀和，sum[i],表示1~i的和，数学内容，简单，自行思考原理 
{ 
	return sum[j] - sum[i - 1]; 
}
</code></pre>
<p>为什么是 <strong>区间和</strong> 呢？</p>
<p>其实 区间和就是两堆的重量（简单，自行思考）</p>
<p>也就是 <strong>合并代价</strong></p>
<hr>
<p>然后是 <strong>初始化</strong></p>
<p>因为是<strong>求最小值</strong>，所以要<strong>开一个大数</strong></p>
<pre><code class="language-cpp">memset(f, 27, sizeof(f));
</code></pre>
<p><strong>27其实计算机会认为是一个很大的数</strong>，接近int边界，并不是我们认为的27</p>
<p><s>也可以换成其他数</s></p>
<hr>
<pre><code class="language-cpp">    for (int i = 1; i &lt;= n; i++) 
	{
        cin &gt;&gt; a[i];
        sum[i] = sum[i - 1] + a[i];// 预处理前缀和
        f[i][i] = 0;//自己合并自己不需要代价 
    }
</code></pre>
<p>输入可以<strong>同时处理</strong></p>
<p>见代码，<strong>sum可以求</strong>，因为<strong>自己合并自己不需要代价 ，所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(i,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>始终为0</strong></p>
<hr>
<p>接下来<strong>讲解dp部分</strong></p>
<p>由于我们已经<strong>知道起点和区间大小，所以可以求终点</strong></p>
<p><s>然后枚举中点就完了</s></p>
<pre><code class="language-cpp">    for (int k = 2; k &lt;= n; k++)//k,枚举区间大小 
	{ 这个p是什么呢？

p数组用来记录最优解的中点 

Why？


        for (int i = 1; i &lt;= n; i++) //i,枚举起点 
		{
            int j = i + k - 1;//求终点 
            for (int l = i; l &lt; j; l++)//枚举中点，这里可以优化，详见PPT《DP之四边形不等式优化》 
			 {
                if (f[i][j] &gt; f[i][l] + f[l + 1][j] + query(i, j)) //求最小值 
				{
                    f[i][j] = f[i][l] + f[l + 1][j] + query(i, j);
                    p[i][j] = l;//有新的最小值,更新中点 
                }
            }
        }
    }
</code></pre>
<p>这个p是什么呢？</p>
<p>p数组用来记录<strong>最优解的中点</strong></p>
<p>Why？</p>
<hr>
<p>由于题目要<strong>求过程</strong>，我们可以用<strong>递归求解</strong></p>
<p>这时p就派上用场了</p>
<p><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>表示合并i,j时的中点k</strong></p>
<p>由此<strong>将l,r分成两份，不断递归</strong></p>
<pre><code class="language-cpp">
void dg(int l, int r) 
{
    if (l == r) {//说明只有一个数，直接输出！ 
        cout &lt;&lt; a[r];//不要换行！不要空格！ 
        return;
    }
    cout &lt;&lt; '(';//输出左右括号 
    int mid = p[l][r];//读取中点 
    dg(l, mid);//递归左半部分 
    cout &lt;&lt; &quot;)(&quot;;//输出中间括号 
    dg(mid + 1, r);//递归右半部分
    cout &lt;&lt; ')';//输出左右括号 
}
</code></pre>
<hr>
<p>好了，这就是关于合并石子的全部内容了</p>
<h1 id="上代码"><strong>上代码！</strong></h1>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int n, a[1005], f[1005][1005], p[1005][1005], sum[1005];
int query(int i, int j) 
{ 
	return sum[j] - sum[i - 1]; 
}
void dg(int l, int r) 
{
    if (l == r) {
        cout &lt;&lt; a[r];
        return;
    }
    cout &lt;&lt; '(';
    int mid = p[l][r];
    dg(l, mid);
    cout &lt;&lt; &quot;)(&quot;;
    dg(mid + 1, r);
    cout &lt;&lt; ')';
}
int main() {
    memset(f, 27, sizeof(f));
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++) 
	{
        cin &gt;&gt; a[i];
        sum[i] = sum[i - 1] + a[i];
        f[i][i] = 0;
    }
    for (int k = 2; k &lt;= n; k++)
	{ 
        for (int i = 1; i &lt;= n; i++) 
		{
            int j = i + k - 1;
            for (int l = i; l &lt; j; l++)
			 {
                if (f[i][j] &gt; f[i][l] + f[l + 1][j] + query(i, j)) 
				{
                    f[i][j] = f[i][l] + f[l + 1][j] + query(i, j);
                    p[i][j] = l;
                }
            }
        }
    }
    cout &lt;&lt; f[1][n] &lt;&lt; endl; 
    dg(1, n);
    return 0;
}
</code></pre>
<hr>
<p>记忆化搜索<strong>更加清晰，易于理解</strong></p>
<p>(不过无法使用<strong>四边形不等式优化</strong>)</p>
<hr>
<h2 id="浅谈记忆化">浅谈记忆化：</h2>
<p>如果说<strong>动态规划</strong>是<strong>递推</strong>，那<strong>记忆化</strong>就是<strong>递归</strong></p>
<h3 id="它的思路是">它的思路是：</h3>
<p>同<strong>动态规划</strong>，若子问题的解<strong>永远不变</strong>，再次计算便<strong>没有意义</strong></p>
<p>我们将其记录在 f 数组或dp数组（命名习惯不同）</p>
<p>但<strong>动态规划</strong>算出了<strong>所有子问题</strong></p>
<p>所以，我们用<strong>递归求解</strong>，保证只求到<strong>有用子问题</strong></p>
<p>但其实因为<strong>递归实现</strong>，二者<strong>复杂度接近</strong>，<strong>动态规划</strong>较快</p>
<hr>
<h3 id="它的框架是">它的框架是：</h3>
<pre><code class="language-cpp">类型 dg(参数)
{
    if(f[参数]已经计算过)return f[参数];
    if(边界)return 对应的数;  //如果已经给边界初始化，可以省略
    计算 
    f[参数]=解//保存解
    return 解;
}
</code></pre>
<p>注意！使用<strong>递归函数表示子问题</strong>！</p>
<hr>
<h2 id="代码详解">代码详解：</h2>
<pre><code class="language-cpp">memset(f,-1, sizeof(f));
n = read();//又 用 快 读
for (int i = 1; i &lt;= n; i++) {
    a[i] = read();
    p[i][i]=i;
}
</code></pre>
<h3 id="输入初始化">输入，初始化</h3>
<p>注意！f = -1 表示 <strong>未计算</strong>！</p>
<hr>
<p><strong>前缀和</strong>略</p>
<hr>
<pre><code class="language-cpp">printf(&quot;%ld\n&quot;, dg(1, n));//输出解
dfs(1, n);//求过程
</code></pre>
<p>主函数完</p>
<hr>
<p><strong>求过程</strong>略</p>
<hr>
<p><strong>记忆化部分</strong>和<strong>动态规划</strong>很像，因为我们知道了<strong>起点i</strong>和<strong>终点j</strong></p>
<p>所以<strong>处理完边界</strong>后，可以直接<strong>枚举中点</strong></p>
<pre><code class="language-cpp">long dg(int i, int j) 
{
    if(i==j)return 0;//边界，自己合并自己不需要代价
    if (f[i][j] != -1) //如果计算了，返回
	{
        return f[i][j];
    }
    f[i][j]=1E9;
    for (int k = i; k &lt;= j; k++) //计算
	{
        if (f[i][j] &gt; dg(i, k) + dg(k + 1, j) + w(i, j)) //注意!用dg表示子问题！
		{
            f[i][j] = dg(i, k) + dg(k + 1, j) + w(i, j);
            p[i][j] = k;//记录中点
        }
    }
    return f[i][j];//返回
}
</code></pre>
<hr>
<h2 id="上代码-2">上代码：</h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

inline int read() {
    int ans = 0;
    char c = getchar();
    while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c != '-')) {
        c = getchar();
    }
    ans = c - '0';
    c = getchar();
    while (c &gt;= '0' &amp;&amp; c &lt;= '9') {
        ans = (ans &lt;&lt; 3) + (ans &lt;&lt; 1) + c - '0';
        c = getchar();
    }
    return ans;
}
long f[105][105], p[105][105], a[105], sum[105], n, mn = 1E9;
long w(long i, long j)
{
	return sum[j] - sum[i - 1]; 
}
void dfs(int l, int r) {
    if (l == r) {
        cout &lt;&lt; a[r];
        return;
    }
    cout &lt;&lt; '(';
    int mid = p[l][r];
    dfs(l, mid);
    cout &lt;&lt; &quot;)(&quot;;
    dfs(mid + 1, r);
    cout &lt;&lt; ')';
}
long dg(int i, int j) 
{
    long x, y;
    if(i==j)return 0;
    if (f[i][j] != -1) 
	{
        return f[i][j];
    }
    f[i][j]=1E9;
    for (int k = i; k &lt;= j; k++) 
	{
        if (f[i][j] &gt; dg(i, k) + dg(k + 1, j) + w(i, j)) 
		{
            f[i][j] = dg(i, k) + dg(k + 1, j) + w(i, j);
            p[i][j] = k;
        }
    }
    return f[i][j];
}
int main() {
    memset(f,-1, sizeof(f));
    n = read();
    for (int i = 1; i &lt;= n; i++) {
        a[i] = read();
        p[i][i]=i;
	}
    for (int i = 1; i &lt;= n; i++) {
        sum[i] = sum[i - 1] + a[i];
    }
    printf(&quot;%ld\n&quot;, dg(1, n));
    dfs(1, n);
}
</code></pre>
<h2 id="题目大意-2">题目大意：</h2>
<blockquote>
<p>在一<strong>圆形操场</strong>四周摆放N堆石子 , 现要将石子<strong>有次序</strong>地合并成一堆.</p>
<p>规定每次只能<strong>选相临的两堆</strong>合并成一堆,<strong>并将新的一堆的石子数,记为该次合并的得分</strong>。</p>
<p>编一程序,<strong>选择一种合并石子的方案</strong>,使得<strong>做N-1次合并</strong>,得分的<strong>总和最少</strong></p>
<p><s>但数据高达n&lt;=2500</s></p>
</blockquote>
<hr>
<h2 id="知识讲解">知识讲解：</h2>
<p>在<strong>动态规划问题</strong>中，有一个<strong>常见的状态转移方程</strong>：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>)</mo><mo>+</mo><mi>w</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f(i,j)=min(f(i,k)+f(k+1,j))+w[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></p>
<p>注意上面的粗体部分</p>
<p>min——求<strong>最小</strong>值</p>
<p>k——枚举的<strong>中点</strong><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">w[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>——一个<strong>区间处理</strong>的函数（如<strong>前缀和</strong>）</p>
<p>这种公式就是将<strong>一个问</strong> <strong>题</strong> 通过 <strong>一个枚举的中点</strong>将问题<strong>拆成两半</strong>，然后加上<strong>一个其他利益的计算函数</strong></p>
<hr>
<p>这种公式若有<strong>这三个元素</strong>，可以如下<strong>判断</strong>：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">w[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>是否满足<strong>两个性质</strong>：</p>
<p>1.若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>i</mi><mi mathvariant="normal">’</mi><mo>&lt;</mo><mi>j</mi><mo>&lt;</mo><mi>j</mi><mi mathvariant="normal">’</mi></mrow><annotation encoding="application/x-tex">i&lt;i’&lt;j&lt;j’</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mord">’</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">’</span></span></span></span>,则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>[</mo><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><mi>j</mi><mo>]</mo><mo>&lt;</mo><mo>=</mo><mi>w</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><msup><mi>j</mi><mo mathvariant="normal">′</mo></msup><mo>]</mo></mrow><annotation encoding="application/x-tex">w[i&#x27;,j]&lt;=w[i,j&#x27;]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>——<strong>区间包含</strong></p>
<p><strong>解析</strong> <strong>：<strong>其实很好理解，<strong>整个区间</strong>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><msup><mi>j</mi><mo mathvariant="normal">′</mo></msup><mo>]</mo><mo separator="true">,</mo><mi>w</mi><mo>[</mo><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">w[i,j&#x27;],w[i&#x27;,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>是里面的</strong>小区间</strong>，我们判断时只要看<strong>整体里的小区间是否一定小于整体区间即可</strong></p>
<p>如：<strong>区间和</strong>就是一个<strong>区间包含</strong>，比如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mi mathvariant="normal">（</mi><mn>1</mn><mo separator="true">,</mo><mn>6</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">sum（1,6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord cjk_fallback">（</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">)</span></span></span></span><strong>一定大于</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">sum(2,4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span></span></span></span></p>
<p>2.若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>i</mi><mi mathvariant="normal">’</mi><mo>&lt;</mo><mi>j</mi><mo>&lt;</mo><mi>j</mi><mi mathvariant="normal">’</mi></mrow><annotation encoding="application/x-tex">i&lt;i’&lt;j&lt;j’</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mord">’</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">’</span></span></span></span>,则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>+</mo><mi>w</mi><mo>(</mo><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>j</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo><mo>&lt;</mo><mo>=</mo><mi>w</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><msup><mi>j</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo><mo>+</mo><mi>w</mi><mi mathvariant="normal">（</mi><msup><mi>i</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">w(i,j)+w(i&#x27;,j&#x27;)&lt;=w(i,j&#x27;)+w（i&#x27;,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>——<strong>平行四边形不等式。</strong></p>
<p>为什么<strong>叫平行四边形不等式</strong>？<s>我不知道</s></p>
<p><s>但是我们大概记一下即可</s></p>
<p>可以证明：<strong>若w满足区间包含单调性</strong>和<strong>平行四边形不等式</strong>，则<strong>f也满足区间平行四边形不等式的性质</strong>。</p>
<p><s>不用记证明，我们记结论</s></p>
<hr>
<p>设s(i,j)表示f(i,j)的<strong>最佳决策点</strong></p>
<p>也就是f <strong>(i,j)为最小值</strong>时的<strong>中点k</strong></p>
<p>则s满足</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">​</mi><mi>s</mi><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>(</mo><mi>j</mi><mo>)</mo><mo>&lt;</mo><mo>=</mo><mi>s</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>&lt;</mo><mo>=</mo><mi>s</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>(</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">​</mi><mi>s</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>&lt;</mo><mo>=</mo><mi>s</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>&lt;</mo><mo>=</mo><mi>s</mi><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>(</mo><mi>j</mi><mo>)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}

​	s(i-1)(j)&lt;=s(i,j)&lt;=s(i)(j+1)\\

​	s(i)(j-1)&lt;=s(i,j)&lt;=s(i+1)(j)
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">​</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">​</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>但只适用于<strong>求min</strong></p>
<p>想一想，为什么？</p>
<p>答案将在<strong>树的构造</strong>的题解公布</p>
<hr>
<p>这样，我们可以<strong>减少枚举的次数</strong></p>
<p>显然，k的<strong>最优解</strong>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">s(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></p>
<p><strong>范围缩小</strong>了</p>
<p>因为我们求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">s(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>,</p>
<p><strong>一定需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>(</mo><mi>j</mi><mo>)</mo><mi mathvariant="normal">，</mi><mi>s</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>(</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">s(i-1)(j)，s(i)(j+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></strong></p>
<p><strong>或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">，</mi><mi>s</mi><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>(</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">s(i)(j-1)，s(i+1)(j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></strong></p>
<p>所以我们需要选择，</p>
<p>两个不等式，需一个i<strong>从大到小</strong>枚举，需一个j<strong>从大到小</strong>枚举</p>
<p>Ps：我们要判断s<strong>是否为零</strong>，如果为零就<strong>仍用i~j</strong></p>
<p>蒟蒻讲的可能不标准，详见PPT</p>
<hr>
<h2 id="题目详解">题目详解：</h2>
<p>合并石子公式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>l</mi><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>+</mo><mi>w</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f(i,j)=min(f(i,l)+f(l+1,j)+w(i,j))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<p><strong>具有三要素</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">w(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>为<strong>区间和</strong></p>
<p>满足 <strong>区间包含单调性</strong>和<strong>平行四边形不等式</strong></p>
<p>可以用<strong>平行四边形不等式</strong>优化</p>
<p>j是由i计算的，所以使用i从大到小的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>&lt;</mo><mo>=</mo><mi>s</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>&lt;</mo><mo>=</mo><mi>s</mi><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>(</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">s(i)(j-1)&lt;=s(i,j)&lt;=s(i+1)(j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></p>
<hr>
<h2 id="代码详解-2">代码详解：</h2>
<p>大多数和版本二<strong>相同</strong></p>
<hr>
<p><strong>输入和初始化</strong>：</p>
<pre><code class="language-cpp">	n=read();//又用了快读，我是有病吗？
	for(int i=1;i&lt;=n;i++)
	{
		a[i]=a[i+n]=read();//输入a
		f[i][i]=f[i+n][i+n]=0;//初始化f
		s[i][i]=i;//分割自己，自己是自己的中点，故s[i][i]=i
		s[i+n][i+n]=i+n;//同上
	}
	n*=2;
</code></pre>
<p>对了，这是个环，<s>但做了版本二后环已经废了，就是来加大数据的</s></p>
<hr>
<p><strong>求前缀和（略）</strong></p>
<hr>
<p>DP部分</p>
<p>没什么注意的</p>
<p>重点是i<strong>从大到小</strong></p>
<pre><code class="language-cpp">	for(int k=2;k&lt;=n/2;k++)//区间大小
	{
		for(int i=n-k+1;i&gt;=1;i--)//从大到小枚举起点
		{
			int j=i+k-1,x,y;//求终点
			if(s[i][j-1])//如果s(i,j-1)为0，从i开始
			{
				x=s[i][j-1];
			}
			else
			{
				x=i;
			}
			if(s[i+1][j])//如果s(i+1,j)为0，从j结束
			{
				y=s[i+1][j];
			}
			else
			{
				y=j;
			}			
			for(int l=x;l&lt;=y;l++)//同版本二
			{
				if(f[i][j]&gt;f[i][l]+f[l+1][j]+w(i,j))
				{
					f[i][j]=f[i][l]+f[l+1][j]+w(i,j);
					s[i][j]=l;
				}
			}
		} 		
	}	
</code></pre>
<hr>
<p>因为<strong>有多种可行方案</strong>，所以我们<strong>循环</strong>要<strong>找一个min</strong></p>
<pre><code class="language-cpp">	for(int i=1;i&lt;=n/2;i++)
	{
		mn=min(mn,f[i][i+n/2-1]);
	}
</code></pre>
<hr>
<p>输出即可</p>
<hr>
<h2 id="上代码-3">上代码：</h2>
<p>没忍住打了个快读</p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;bits/stdc++.h&gt;
using namespace std;

inline int read() 
{
    int ans = 0;
    char c = getchar();
    while ((c &lt; '0' || c &gt; '9') &amp;&amp; (c != '-'))
	{
		c = getchar();
	}
    ans = c - '0';
	c = getchar();
    while (c &gt;= '0' &amp;&amp; c &lt;= '9') 
	{
		ans = (ans &lt;&lt; 3) + (ans &lt;&lt; 1) + c - '0';
		c = getchar();
	}
    return ans;
}
long f[5005][5005],s[5005][5005],a[5005],sum[5005],n,mn=1E8;
long w(long i,long j)
{
	return sum[j]-sum[i-1];
}
int main()
{
	memset(f,127,sizeof(f));
	n=read();
	for(int i=1;i&lt;=n;i++)
	{
		a[i]=a[i+n]=read();
		f[i][i]=f[i+n][i+n]=0;
		s[i][i]=i;
		s[i+n][i+n]=i+n;
	}
	n*=2;
	for(int i=1;i&lt;=n;i++)
	{
		sum[i]=sum[i-1]+a[i];
	}
	for(int k=2;k&lt;=n/2;k++)
	{
		for(int i=n-k+1;i&gt;=1;i--)
		{
			int j=i+k-1,x,y;
			if(s[i][j-1])
			{
				x=s[i][j-1];
			}
			else
			{
				x=i;
			}
			if(s[i+1][j])
			{
				y=s[i+1][j];
			}
			else
			{
				y=j;
			}			
			for(int l=x;l&lt;=y;l++)
			{
				if(f[i][j]&gt;f[i][l]+f[l+1][j]+w(i,j))
				{
					f[i][j]=f[i][l]+f[l+1][j]+w(i,j);
					s[i][j]=l;
				}
			}
		} 		
	}	
	for(int i=1;i&lt;=n/2;i++)
	{
		mn=min(mn,f[i][i+n/2-1]);
	}
	printf(&quot;%d&quot;,mn);
}
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://Deng-Duck.github.io/tag/Answer/" class="tag">
                    题目解法
                  </a>
                
                  <a href="https://Deng-Duck.github.io/tag/Algorithm/" class="tag">
                    算法总结
                  </a>
                
              </div>
            
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>





  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '0b9d02ba11c879947681',
        clientSecret: '46a1e446e3f04c37e7a17c88e62197a7378254a4',
        repo: 'gitalk',
        owner: 'deng-duck',
        admin: ['deng-duck'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
